{"version":3,"file":"beskydy.js","sources":["../src/evaluate.ts","../src/context.ts","../src/helpers.ts","../src/directives/x-ref.ts","../src/text-node.ts","../src/directives/x-text.ts","../src/directives/x-style.ts","../src/directives/x-show.ts","../src/directives/x-html.ts","../src/directives/x-bind.ts","../src/directives/x-class.ts","../src/directives/x-on.ts","../src/directives/x-if.ts","../src/directives/x-model.ts","../src/directives/x-for.ts","../src/directives/x-portal.ts","../src/directives/x-data.ts","../src/directives/x-switch.ts","../src/directives/x-spy.ts","../src/directives/x-lifecycle.ts","../src/walker.ts","../src/beskydy.ts","../src/index.ts"],"sourcesContent":["/**\r\n * Thank you so much Evan You, I love you\r\n */\r\n\r\nconst evalCache: Record<string, Function> = Object.create(null)\r\n\r\nexport function evaluate(scope: any, exp: string, el?: Node) {\r\n  return execute(scope, `return(${exp})`, el)\r\n}\r\n\r\nexport function execute(scope: any, exp: string, el?: Node, event?: Event) {\r\n  // By calling stringify, the function hits every single property within an\r\n  // object. No matter how deep it is. This way we can ensure deep reactivity\r\n  // Thanks to Alpine.js core for the tip\r\n  JSON.stringify(scope)\r\n\r\n  const fn = evalCache[exp] || (evalCache[exp] = toFunction(exp))\r\n  try {\r\n    return fn(scope, el, event)\r\n  }\r\n  catch (e) {\r\n    if (import.meta.env.DEV) {\r\n      // console.log(scope)\r\n      console.warn(`Error when evaluating expression \"${exp}\":`)\r\n    }\r\n    console.error(e)\r\n  }\r\n}\r\n\r\nfunction toFunction(exp: string): Function {\r\n  try {\r\n    // eslint-disable-next-line no-new-func\r\n    return new Function('data', '$el', '$event', `with(data){${exp}}`)\r\n  }\r\n  catch (e) {\r\n    console.error(`${(e as Error).message} in expression: ${exp}`)\r\n    return () => { }\r\n  }\r\n}\r\n","import type { ReactiveEffectRunner, UnwrapNestedRefs } from '@vue/reactivity'\r\nimport { effect as rawEffect, reactive } from '@vue/reactivity'\r\nimport type { Beskydy } from './beskydy'\r\nimport { evaluate } from './evaluate'\r\n\r\nexport type ContextAny = Context<Element, Beskydy<object>, object>\r\n\r\n// Piece of DOM which holds its own state. This class can be used on its\r\n// own, but requires an instance of Beskydy to provide modifiers to a\r\n// few directives.\r\n\r\n// In case you want to create custom context, you can just do:\r\n// const ctx = new Context(root, new Beskydy())\r\n\r\nexport class Context<R extends Element, A extends Beskydy<object>, T extends object> {\r\n  // Store the context's root element\r\n  root: Element\r\n  // Reactive dataset available to the entire scope\r\n  data: UnwrapNestedRefs<T & { $refs: Record<string, Element> }>\r\n  init: boolean\r\n  // Hold all context runners for disposal\r\n  effects: ReactiveEffectRunner[] = []\r\n\r\n  // Stores a referene to the root app instance\r\n  app: Beskydy<object>\r\n\r\n  constructor(root: R, app: A, initialDataset?: T) {\r\n    this.root = root\r\n    this.data = reactive(Object.assign({ $refs: {} }, app.rootState, initialDataset))\r\n    this.init = false\r\n    this.app = app\r\n  }\r\n\r\n  /**\r\n   * Executes the provided callback fn whenever the context's reactive\r\n   * dataset updates\r\n   *\r\n   * @param fn Callback\r\n   */\r\n  effect(fn: () => any) {\r\n    const handler = rawEffect(fn)\r\n    this.effects.push(handler)\r\n  }\r\n\r\n  /**\r\n   * Stores a reference to a DOM element by the provided key. This\r\n   * allows us to use $refs object within expressions\r\n   *\r\n   * @param key Ref key\r\n   * @param ref Element\r\n   */\r\n  addRef(key: string, ref: Element) {\r\n    Object.assign(this.data.$refs, { [key]: ref })\r\n  }\r\n\r\n  /**\r\n   * When creating sub contexts, this allows for a parent context to\r\n   * share its reactive properties with the child context\r\n   *\r\n   * @param ctx Context\r\n   */\r\n  extend(ctx: ContextAny) {\r\n    Object.assign(this.data, ctx.data)\r\n  }\r\n\r\n  /**\r\n   * Evaluates the provided expression against the context dataset\r\n   *\r\n   * @param expr Expression\r\n   * @param el Optionally, make the current element available as $el\r\n   * @returns Evaluated value\r\n   */\r\n  eval(expr: string, el?: Node | undefined) {\r\n    return evaluate(this.data, expr, el)\r\n  }\r\n\r\n  /**\r\n   * Turns the scope's elements to the original static HTML. Removes\r\n   * event listeners and stops reactive watchers.\r\n   */\r\n  teardown() {\r\n    // Iterate over all children of a ctx and remove any beskydy functionality\r\n    this.effects.forEach(e => e.effect.stop())\r\n    this.effects.length = 0\r\n\r\n    // Clone whole subtree and re-attach it to the parent. This removes any event listeners\r\n    const clone = this.root.cloneNode(true)\r\n    this.root.parentElement?.replaceChild(clone, this.root)\r\n\r\n    // Overwrite context dataset with an empty object\r\n    Reflect.set(this, 'data', Object.create(null))\r\n\r\n    this.init = false\r\n  }\r\n}\r\n","import type { Primitive } from './directives/directives'\r\nimport type { ContextAny } from './context'\r\nimport { evaluate } from './evaluate'\r\n\r\nexport function isSibling(el: HTMLElement, el2: HTMLElement) {\r\n  return el !== el2 && el.parentNode === el2.parentNode\r\n}\r\n\r\nexport function getAttr(el: HTMLElement | Element, key: string) {\r\n  const attr = el.attributes.getNamedItem(key)\r\n  if (!attr)\r\n    return null\r\n  el.removeAttribute(key)\r\n  return attr.value ?? true\r\n}\r\n\r\nexport function isNil(value: unknown) {\r\n  return value === undefined || value === null\r\n}\r\n\r\nexport function isObj(value: unknown) {\r\n  return (!!value) && (value.constructor === Object)\r\n}\r\n\r\nexport const isArr = Array.isArray\r\n\r\nexport const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport function removeChildren(node: Element) {\r\n  while (node.lastElementChild)\r\n    node.removeChild(node.lastElementChild)\r\n}\r\n\r\nexport function isType(val: any, requiredType: Primitive) {\r\n  // eslint-disable-next-line valid-typeof\r\n  return typeof val === requiredType\r\n}\r\n\r\nexport function parseValue(value: string, ctx: ContextAny): Primitive {\r\n  if (value in ctx.data) {\r\n    return evaluate(ctx.data, value)\r\n  }\r\n  else {\r\n    if (value === 'undefined')\r\n      return undefined\r\n    else if (value === 'null')\r\n      return null\r\n    else if (value === 'true' || value === 'false')\r\n      return Boolean(value)\r\n    // eslint-disable-next-line unicorn/prefer-number-properties\r\n    else if (!isNaN(value as any))\r\n      return Number(value)\r\n    else\r\n      return value\r\n  }\r\n}\r\n\r\n/**\r\n * Execute given callback on the next browser repaint. It also returns a\r\n * promise, so instead of a callback, it can be awaited.\r\n *\r\n * @param callback\r\n * @returns Promise\r\n */\r\nexport function nextTick(callback?: () => void) {\r\n  return new Promise((resolve) => {\r\n    requestAnimationFrame(() => {\r\n      if (callback)\r\n        callback()\r\n      resolve(true)\r\n    })\r\n  })\r\n}\r\n\r\nexport function getElementIndex(child: Node | null): number {\r\n  let i = 0\r\n  while ((child = child!.previousSibling) != null)\r\n    i++\r\n\r\n  return i\r\n}\r\n","import type { Directive } from './directives'\r\n\r\nexport const processRef: Directive = function (ctx, node, { value, name }) {\r\n  node.removeAttribute(name)\r\n  // Add ref once\r\n  ctx.addRef(value, node)\r\n\r\n  // Update whenever ref's items are changed\r\n  const mo = new MutationObserver(() => {\r\n    ctx.addRef(value, node)\r\n  })\r\n\r\n  mo.observe(node, {\r\n    attributes: true,\r\n    childList: true,\r\n    subtree: true,\r\n    characterData: true,\r\n  })\r\n}\r\n","import type { ContextAny } from './context'\r\nimport { evaluate } from './evaluate'\r\nimport { isObj } from './helpers'\r\n\r\nexport function toDisplayString(value: any) {\r\n  return value == null\r\n    ? ''\r\n    : isObj(value)\r\n      ? JSON.stringify(value, null, 2)\r\n      : String(value)\r\n}\r\n\r\nexport function processTextNode(ctx: ContextAny, node: Node) {\r\n  // This should never be hit as only text nodes are processed, but\r\n  // typescript is a known crybaby\r\n  if (!node.textContent || node.textContent.trim().length === 0)\r\n    return\r\n\r\n  const delimiters = ctx.app.delimiters\r\n\r\n  // Save the original expression\r\n  const originalTextContent = node.textContent\r\n\r\n  ctx.effect(() => {\r\n    if (originalTextContent.includes(delimiters.start)) {\r\n      const segments: string[] = []\r\n      let lastIndex = 0\r\n      let match\r\n      while ((match = delimiters.re.exec(originalTextContent))) {\r\n        const leading = originalTextContent.slice(lastIndex, match.index)\r\n        if (leading)\r\n          segments.push(JSON.stringify(leading))\r\n        segments.push(toDisplayString(`${match[1]}`))\r\n        lastIndex = match.index + match[0].length\r\n      }\r\n      if (lastIndex < originalTextContent.length)\r\n        segments.push(JSON.stringify(originalTextContent.slice(lastIndex)))\r\n\r\n      node.textContent = evaluate(ctx.data, segments.join('+'))\r\n    }\r\n    else {\r\n      node.textContent = toDisplayString(originalTextContent)\r\n    }\r\n  })\r\n}\r\n","import { toDisplayString } from '../text-node'\r\nimport type { Directive } from './directives'\r\n\r\nexport const processText: Directive = function (ctx, node, { name, value }) {\r\n  node.removeAttribute(name)\r\n  const expr = value\r\n  ctx.effect(() => {\r\n    node.textContent = toDisplayString(ctx.eval(expr, node))\r\n  })\r\n}\r\n","import { isObj } from '../helpers'\r\nimport type { Directive } from './directives'\r\n\r\nexport const processStyle: Directive = function (ctx, node, { value, name }) {\r\n  node.removeAttribute(name)\r\n\r\n  const expr = value\r\n\r\n  ctx.effect(() => {\r\n    const result = ctx.eval(expr, node)\r\n\r\n    if (!isObj(result))\r\n      return\r\n\r\n    for (const key of Object.keys(result)) {\r\n      // If it's a non HTMLElement node, skip it\r\n      if (!Reflect.has(node, 'style'))\r\n        continue\r\n\r\n      // Using reflect set allows us using camelCase and kebab-case styles\r\n      Reflect.set((node as HTMLElement).style, key, result[key])\r\n    }\r\n  })\r\n}\r\n","import type { Directive } from './directives'\r\n\r\n/**\r\n * Takes in and evaluates an expression. Based on the result the element\r\n * is either shown or hidden in the DOM.\r\n */\r\nexport const processShow: Directive = function (ctx, node, { value, name }) {\r\n  node.removeAttribute(name)\r\n\r\n  const expr = value\r\n\r\n  if (!Reflect.has(node, 'style'))\r\n    return\r\n\r\n  ctx.effect(() => {\r\n    const result = ctx.eval(expr, node)\r\n    if (result)\r\n      (node as HTMLElement).style.removeProperty('display')\r\n    else\r\n      (node as HTMLElement).style.setProperty('display', 'none')\r\n  })\r\n}\r\n","import type { Directive } from './directives'\r\n\r\nexport const processHTML: Directive = function (ctx, node, { value, name }) {\r\n  node.removeAttribute(name)\r\n  const expr = value\r\n  ctx.effect(() => {\r\n    const result = ctx.eval(expr, node)\r\n\r\n    if (result instanceof Element) {\r\n      node.replaceChildren()\r\n      node.append(result)\r\n    }\n    else {\r\n      node.innerHTML = result\r\n    }\r\n  })\r\n}\r\n","import { isNil } from '../helpers'\r\nimport type { Directive } from './directives'\r\n\r\n/**\r\n * Dynamically bind attribute or attributes if the expression passes\r\n *\r\n * Allowed syntax\r\n *\r\n * This syntax will bind a value-less attribute (boolean attribute) if the expression matches\r\n * - :attributeName=\"expression\"\r\n * - x-bind:attributeName=\"expression\"\r\n * - x-bind=\"{ attributeValue: expression }\"\r\n */\r\nexport const processBind: Directive = function (ctx, node, { name, value }) {\r\n  node.removeAttribute(name)\r\n\r\n  const [_, propertyName] = name.split(':')\r\n\r\n  const setOrDelAttr = (key: string, value: any) => {\r\n    // If no value is provided or the value is a boolean, remove the\r\n    // attribute instead of simply setting it to the value.\r\n\r\n    // The reason for that is disabled=\"false\" will still disable the\r\n    // attribute, as boolean attributes dont care about the value\r\n    if (isNil(value) || value === false)\r\n      node.removeAttribute(key)\r\n    else\r\n      node.setAttribute(key, value)\r\n  }\r\n\r\n  if (propertyName) {\r\n    // x-bind:propertyName=\"\" syntax\r\n    ctx.effect(() => {\r\n      const result = ctx.eval(value, node)\r\n      setOrDelAttr(propertyName, result)\r\n    })\r\n  }\r\n  else {\r\n    // x-bind=\"{}\" syntax\r\n    ctx.effect(() => {\r\n      const results = ctx.eval(value, node) ?? {}\r\n\r\n      for (const key of Object.keys(results)) {\r\n        const result = results[key]\r\n        setOrDelAttr(key, result)\r\n      }\r\n    })\r\n  }\r\n}\r\n","import { isObj } from '../helpers'\r\nimport type { Directive } from './directives'\r\n\r\nexport const processClass: Directive = function (ctx, node, { value }) {\r\n  const assignObjectClasses = (parsed: Record<string, unknown>) => {\r\n    for (const key of Object.keys(parsed)) {\r\n      if (parsed[key])\r\n        node.classList.add(key)\r\n      else\r\n        node.classList.remove(key)\r\n    }\r\n  }\r\n\r\n  if (value.startsWith('[')) {\r\n    // Evaluate Should receive an array of strings or objects. Iterate on it and\r\n    // call either of the process functions\r\n    const prevInlineResults: Record<number, string | null> = Object.create(null)\r\n\r\n    ctx.effect(() => {\r\n      const results = ctx.eval(value)\r\n\r\n      for (let i = 0; i < results.length; i++) {\r\n        const result = results[i]\r\n\r\n        if (!result) {\r\n          const prevResult = prevInlineResults[i]\r\n\r\n          if (prevResult) {\r\n            node.classList.remove(prevResult)\r\n            prevInlineResults[i] = null\r\n          }\r\n        }\r\n        else if (typeof result === 'string') {\r\n          node.classList.add(result)\r\n          prevInlineResults[i] = result\r\n        }\r\n        else if (isObj(result)) {\r\n          assignObjectClasses(result)\r\n        }\r\n      }\r\n    })\r\n  }\r\n  else if (value.startsWith('{') && value.endsWith('}')) {\r\n    // Processes object expression. If the value is truthy, the key will be\r\n    // assigned as a classname\r\n    // Eg: { className: expression, display: isVisible }\r\n    ctx.effect(() => {\r\n      const parsed: Record<string, unknown> = ctx.eval(value, node)\r\n      assignObjectClasses(parsed)\r\n    })\r\n  }\r\n  else {\r\n    // Processes inline ternary operator expression\r\n    // Eg: \"value ? 'class' : null\"\r\n    let previous: string\r\n    ctx.effect(() => {\r\n      if (previous)\r\n        node.classList.remove(previous)\r\n\r\n      previous = ctx.eval(value, node)\r\n      node.classList.add(previous)\r\n    })\r\n  }\r\n}\r\n","import { execute } from '../evaluate'\r\nimport { parseValue } from '../helpers'\r\nimport type { Directive, EventModifierFn, Modifier, ModifierListenerState, Primitive } from './directives'\r\n\r\n// Default event modifiers which are bound to an app instance\r\nexport const eventModifiers: Record<string, EventModifierFn> = {\r\n  throttle: (_, { lastCall }, amount = 300) => {\r\n    if (typeof amount !== 'number')\r\n      return false\r\n    if (Date.now() - lastCall >= amount)\r\n      return true\r\n    return false\r\n  },\r\n  if: (_, __, rawEval) => !!rawEval,\r\n  only: (_, { calledTimes }, callLimit = 1) => {\r\n    if (typeof callLimit !== 'number')\r\n      return false\r\n    return calledTimes < callLimit\r\n  },\r\n  once: (_, { calledTimes }) => calledTimes < 1,\r\n  self: e => e.target === e.currentTarget,\r\n  left: e => 'button' in e && (e as MouseEvent).button === 0,\r\n  middle: e => 'button' in e && (e as MouseEvent).button === 1,\r\n  right: e => 'button' in e && (e as MouseEvent).button === 2,\r\n  prevent: (e) => {\r\n    e.preventDefault()\r\n    return true\r\n  },\r\n  stop: (e) => {\r\n    e.stopPropagation()\r\n    return true\r\n  },\r\n  stopImmediate: (e) => {\r\n    e.stopImmediatePropagation()\r\n    return true\r\n  },\r\n}\r\n\r\n/**\r\n * Binds an event listener with optional modifiers to the selected\r\n * element. The provided expression is evaluated whenever the event is\r\n * fired.\r\n */\r\nexport const processOn: Directive = function (ctx, node, { name, value }) {\r\n  node.removeAttribute(name)\r\n\r\n  // Get the event name and its modifiers. The two supported syntaxes\r\n  // for binding event listeners are using either `@event` or\r\n  // `x-on:event`. With optional modifiers appended by using\r\n  // `@event.modifier.modifier` etc\r\n  const eventKeyRaw = (name.startsWith('x-on') ? name.split(':')[1] : name.substring(1)).split('.')\r\n  const eventKey = eventKeyRaw[0]\r\n\r\n  // Collect optional modifiers from the event name\r\n  // (event.modifier.modifier) and filter out ones which aren't\r\n  // supported (aka user errors)\r\n  const modifiers: Modifier[] = eventKeyRaw\r\n    .slice(1)\r\n    .map((modifier) => {\r\n      // Split modifier into a key and possible parameter\r\n      // eventKey[param]=\"\"\r\n      const [key, rawParams] = modifier.split('[')\r\n      let param: Primitive\r\n\r\n      if (rawParams) {\r\n        const parsedModifier = rawParams.replace(']', '')\r\n        // The parameter can be a reactive variable.\r\n        // So we should evaluate it against the current context, but only if its available\r\n        param = parseValue(parsedModifier, ctx)\r\n      }\r\n\r\n      return { key, param }\r\n    })\r\n    .filter((modifier) => {\r\n      return Object.keys(ctx.app.eventModifiers).includes(modifier.key)\r\n    })\r\n\r\n  if (value.startsWith('('))\r\n    value = `(${value})()`\r\n\r\n  // State variables, which some of the modifiers use\r\n  const state: ModifierListenerState = {\r\n    calledTimes: 0,\r\n    lastCall: 0,\r\n  }\r\n\r\n  node.addEventListener(eventKey, (event: Event) => {\r\n    // Only execute callback if every modifier passes\r\n    if (modifiers.every(modifier => ctx.app.eventModifiers[modifier.key](event, state, modifier.param)))\r\n      execute(ctx.data, value, node, event)\r\n\r\n    state.calledTimes++\r\n    state.lastCall = Date.now()\r\n  })\r\n}\r\n","import { getAttr } from '../helpers'\r\nimport { walk } from '../walker'\r\nimport type { Directive } from './directives'\r\n\r\ninterface Block {\r\n  expr: string | null\r\n  node: HTMLElement\r\n}\r\n\r\n/**\r\n * Takes in an expression and based on its result, the elements are\r\n * either completely removed or (re)added to the DOM.\r\n *\r\n * The usage syntax and rules\r\n *  x-if        // Requires expression\r\n *  x-else-if   // Requires expression and adjacent x-if or x-if-else\r\n *  x-else      // Requires adjacent x-if or x-else\r\n */\r\n\r\nexport const processIf: Directive<boolean> = function (ctx, node, { name, value }) {\r\n  node.removeAttribute(name)\r\n\r\n  // Holds the reference to the element and its parent node\r\n  const parent = node.parentElement!\r\n\r\n  // This serves as an \"anchor\" to mount the element back in if the provided expression returns true\r\n  const anchor = new Comment('x-if')\r\n  parent.insertBefore(anchor, node)\r\n\r\n  // Store each element as a block with its expression\r\n  const blocks: Block[] = [{\r\n    node: node as HTMLElement,\r\n    expr: value,\r\n  }]\r\n\r\n  // Look for v-else-if and v-else elements and their expression\r\n  let elseEl: Element | null\r\n  let elseExpr: string | null\r\n  while ((elseEl = node.nextElementSibling) !== null) {\r\n    if ((elseExpr = getAttr(elseEl, 'x-else')) !== null || (elseExpr = getAttr(elseEl, 'x-else-if'))) {\r\n      blocks.push({\r\n        node: elseEl as HTMLElement,\r\n        expr: elseExpr,\r\n      })\r\n\r\n      // Remove them because they can be re-added during evaluation process\r\n      parent.removeChild(elseEl)\r\n    }\r\n    else {\r\n      // If the NEXT sibling does not contain one of these,\r\n      // stop checking. As only adjacent elements to the first\r\n      // x-if can be tied to it. Gaps aren't allowed\r\n      break\r\n    }\r\n  }\r\n\r\n  parent.removeChild(node)\r\n\r\n  let currentIndex: number\r\n  let currentResult: Block | null\r\n\r\n  function clear() {\r\n    if (currentResult) {\r\n      parent.removeChild(currentResult.node)\r\n      currentResult = null\r\n    }\r\n  }\r\n\r\n  // This is ran just once on initialization. If an x-if has just one\r\n  // node and it doesnt pass the initial evaluation, we should stop the\r\n  // walker from walking through the node tree. By returned true from\r\n  // this process, we'll tell the walker to skip this. It's like\r\n  // conditionally adding x-skip to this.\r\n  let shouldGoNextSibling = false\r\n\r\n  ctx.effect(() => {\r\n    // Iterate over each block and evaluate block expressions\r\n    for (let index = 0; index < blocks.length; index++) {\r\n      const block = blocks[index]\r\n\r\n      if (!block.expr || ctx.eval(block.expr, node)) {\r\n        // Passed\r\n        if (currentIndex !== index) {\r\n          if (currentResult)\r\n            clear()\r\n\r\n          parent.insertBefore(block.node, anchor)\r\n\r\n          // Walk and process again\r\n          walk(ctx, block.node)\r\n\r\n          currentResult = block\r\n          currentIndex = index\r\n        }\r\n        else {\r\n          shouldGoNextSibling = true\r\n        }\r\n\r\n        return\r\n      }\r\n      else {\r\n        shouldGoNextSibling = true\r\n      }\r\n    }\r\n\r\n    currentIndex = -1\r\n    clear()\r\n  })\r\n\r\n  return shouldGoNextSibling\r\n}\r\n","import { isArr, isNil, parseValue } from '../helpers'\r\nimport type { Directive, Primitive } from './directives'\r\n\r\nexport type ModelModifierFn = (value: string, oldValue: string, param?: any) => unknown\r\n\r\nexport const modelModifiers: Record<string, ModelModifierFn> = {\r\n  trim: (value: string) => value.trim(),\r\n  number: (value: string, prevValue: string) => {\r\n    if (Number.isNaN(Number(value)))\r\n      return Number(prevValue)\r\n\r\n    return Number(value)\r\n  },\r\n} as const\r\n\r\nexport type ModelElement = HTMLInputElement | HTMLSelectElement | HTMLDetailsElement | HTMLTextAreaElement\r\ntype Modifier = keyof typeof modelModifiers\r\n\r\nexport const processModel: Directive = function (ctx, el, { name, value }) {\r\n  let node = el as ModelElement\r\n  const [_, modifier] = name.split('.') as [unknown, Modifier]\r\n  const defaultValue = node.attributes.getNamedItem('value')?.value\r\n\r\n  // Call back to execute model modifiers and return the modified value\r\n  const modify = (newValue: string, oldValue: string) => {\r\n    if (!modifier)\r\n      return newValue\r\n\r\n    // Model param\r\n    const [key, rawParams] = modifier.split('[')\r\n    let param: Primitive\r\n\r\n    if (rawParams) {\r\n      const parsedModifier = rawParams.replace(']', '')\r\n      // The parameter can be a reactive variable.\r\n      // So we should evaluate it against the current context, but only if its available\r\n      param = parseValue(parsedModifier, ctx)\r\n    }\r\n\r\n    return ctx.app.modelModifiers[key](newValue, oldValue, param)\r\n  }\r\n\r\n  const assignSimpleDefaultValue = () => {\r\n    let finalValue\r\n    const modelValue = ctx.eval(value)\r\n\r\n    if (!modelValue) {\r\n      if (defaultValue)\r\n        finalValue = defaultValue\r\n    }\r\n    else {\r\n      finalValue = modelValue\r\n    }\r\n\r\n    Object.assign(ctx.data, { [name]: finalValue })\r\n    node = node as HTMLInputElement\r\n    node.value = finalValue\r\n  }\r\n\r\n  switch (node.tagName) {\r\n    case 'INPUT':\r\n    case 'TEXTAREA': {\r\n      node = node as HTMLInputElement\r\n\r\n      switch (node.type) {\r\n        // Listen for 'change' event\r\n        case 'checkbox': {\r\n          const modelValue = Reflect.get(ctx.data, value) as Array<any> | string | undefined | null\r\n\r\n          /**\r\n           * With checkbox, there are multiple cases\r\n           *  - no value:       we toggle checked state as a boolean\r\n           *  - value:          we toggle checked state as its value\r\n           *  - array no value: nothing, array of random booleans makes no sense\r\n           *  - array values:   push / splice out if checked or not\r\n           */\r\n\r\n          const setCheckboxValue = (value: string, checked: boolean) => {\r\n            // Selected but something else: ARRAY\r\n            if (isArr(modelValue)) {\r\n              if (modelValue.includes(value))\r\n                modelValue.splice(modelValue.indexOf(value), 1)\r\n              else\r\n                modelValue.push(value)\r\n            }\r\n            // Primitive\r\n            else {\r\n              Reflect.set(ctx.data, value, isNil(value) ? !checked : value)\r\n            }\r\n          }\r\n\r\n          // If no model value is provided and element contains checked, assign default value\r\n          if ((!modelValue || modelValue.length === 0) && node.hasAttribute('checked')) {\r\n            setCheckboxValue(node.value, true)\r\n            node.removeAttribute('checked')\r\n          }\r\n\r\n          node.addEventListener('change', (evt) => {\r\n            const { checked, value } = evt?.target as HTMLInputElement\r\n            setCheckboxValue(value, checked)\r\n          })\r\n\r\n          ctx.effect(() => {\r\n            node = node as HTMLInputElement\r\n            // Update in case some properties are removed or set elsewhere\r\n            const results = ctx.eval(value)\r\n\r\n            if (results.includes(node.value) || node.value === results)\r\n              node.checked = true\r\n            else\r\n              node.checked = false\r\n          })\r\n          break\r\n        }\r\n\r\n        // Listen for 'change' event\r\n        case 'radio': {\r\n          // Default value\r\n          if (node.hasAttribute('checked')) {\r\n            node.removeAttribute('checked')\r\n            Object.assign(ctx.data, { [value]: node.value })\r\n          }\r\n\r\n          node.addEventListener('change', (evt) => {\r\n            const { checked, value } = evt.target as HTMLInputElement\r\n            if (checked)\r\n              Object.assign(ctx.data, { [value]: value })\r\n          })\r\n\r\n          // If evaluated value changes, make sure to update the HTML as well\r\n          ctx.effect(() => {\r\n            node = node as HTMLInputElement\r\n            const newValue = ctx.eval(value)\r\n            node.checked = node.value === newValue\r\n          })\r\n          break\r\n        }\r\n\r\n        // All other inputs\r\n        default: {\r\n          assignSimpleDefaultValue()\r\n          node.removeAttribute('x-model')\r\n          node.addEventListener('input', (evt) => {\r\n            const target = evt.target as HTMLInputElement\r\n            const rawValue = target.value\r\n            const modifiedValue = modify(rawValue, Reflect.get(ctx.data, value))\r\n\r\n            // If modified value is different than raw value, we need to\r\n            // re-assign this modification back to the original target.\r\n            if (rawValue !== modifiedValue)\r\n              target.value = String(modifiedValue)\r\n\r\n            Object.assign(ctx.data, { [value]: modifiedValue })\r\n          })\r\n\r\n          ctx.effect(() => (node as HTMLInputElement).value = ctx.eval(value))\r\n        }\r\n      }\r\n      break\r\n    }\r\n\r\n    case 'SELECT': {\r\n      node = node as HTMLSelectElement\r\n      assignSimpleDefaultValue()\r\n\r\n      node.addEventListener('change', (evt) => {\r\n        const val = parseValue((evt.target as HTMLSelectElement).value, ctx)\r\n        Object.assign(ctx.data, { [value]: val })\r\n      })\r\n\r\n      ctx.effect(() => (node as HTMLSelectElement).value = ctx.eval(value))\r\n      break\r\n    }\r\n\r\n    case 'DETAILS': {\r\n      node = node as HTMLDetailsElement\r\n      const defaultOpen = node.attributes.getNamedItem('open')\r\n      const currentValue = ctx.eval(value)\r\n\r\n      node.open = !isNil(currentValue) ? currentValue : (defaultOpen ?? false)\r\n\r\n      node.addEventListener('toggle', (evt) => {\r\n        const isOpen = (evt.target as HTMLDetailsElement).open\r\n        Object.assign(ctx.data, { [value]: isOpen })\r\n      })\r\n\r\n      ctx.effect(() => (node as HTMLDetailsElement).open = ctx.eval(value))\r\n      break\r\n    }\r\n  }\r\n}\r\n","import { isArr, isObj, removeChildren } from '../helpers'\r\nimport type { ContextAny } from '../context'\r\nimport { Context } from '../context'\r\nimport { walk } from '../walker'\r\nimport type { Directive } from './directives'\r\n\r\nexport const processFor: Directive = function (ctx, node, { value, name }) {\r\n  node.removeAttribute(name)\r\n  // Remove if from the iterated elements.\r\n  // Use condition on the child elements instead.\r\n  node.removeAttribute('x-if')\r\n\r\n  /**\r\n   * Much more limited that vue's synax. No destructuring.\r\n   * Only supports 3 different types. Array, object and range (number)\r\n   *\r\n   * Iteration of objects\r\n   *  - item in object\r\n   *  - (value, key, index) in object\r\n   *\r\n   * Iteration of arrays\r\n   *  - item in array\r\n   *  - (item, index) in array\r\n   */\r\n\r\n  // First, we split strings\r\n  const [params, _, rawValue] = value.split(/(?!\\(.*)\\s(?![^(]*?\\))/g)\r\n  const parent = node.parentElement\r\n\r\n  /**\r\n   * REVIEW: maybe in the future\r\n   *\r\n   * Evaluation process\r\n   *\r\n   * 1. Generate nodes once and save them to an array\r\n   * 2. On subsequent evaluations, we cache the expression. And iterate on the cached nodes only.\r\n   *  - If expression changes, we remoe all nodes and go back to step #1\r\n   *\r\n   */\r\n  const originalNode = node.cloneNode(true)\r\n  node.remove()\r\n\r\n  // Methods using this scope's variables\r\n  // Create new node and context by cloning the original node.\r\n  const createForItemCtx = () => {\r\n    const newEl = <HTMLElement>originalNode.cloneNode(true)\r\n    const newCtx = new Context(newEl, ctx.app)\r\n    newCtx.extend(ctx)\r\n    return { newEl, newCtx }\r\n  }\r\n\r\n  // Appends the new element to the parent and walks through attribute setup\r\n  // itself and its children.\r\n  const appendAndWalkItem = (newEl: HTMLElement, newCtx: ContextAny) => {\r\n    parent?.appendChild(newEl)\r\n    walk(newCtx)\r\n  }\r\n\r\n  ctx.effect(() => {\r\n    const evalExpr = ctx.eval(rawValue)\r\n\r\n    // Before clearing, should remoev ALL children if they exist\r\n    removeChildren(parent!)\r\n\r\n    // Range\r\n    if (typeof evalExpr === 'number') {\r\n      for (const i in Array.from({ length: evalExpr })) {\r\n        const { newEl, newCtx } = createForItemCtx()\r\n        Object.assign(newCtx.data, { [params]: Number(i) })\r\n        appendAndWalkItem(newEl, newCtx)\r\n      }\r\n    }\r\n    // Item in array\r\n    else if (isArr(evalExpr)) {\r\n      // Extract values from '(value, index?)' string\r\n      const [valueName, indexName] = params.replace('(', '').replace(')', '').split(',')\r\n      const trimmedValueName = valueName.trim()\r\n      const trimmedIndexName = indexName?.trim()\r\n\r\n      evalExpr.forEach((item, index) => {\r\n        const { newEl, newCtx } = createForItemCtx()\r\n\r\n        Object.assign(newCtx.data, { [trimmedValueName]: item })\r\n\r\n        if (trimmedIndexName)\r\n          Object.assign(newCtx.data, { [trimmedIndexName]: Number(index) })\r\n\r\n        appendAndWalkItem(newEl, newCtx)\r\n      })\r\n    }\r\n    // Iterating in object\r\n    else if (isObj(evalExpr)) {\r\n      // Extract values from '(value, key?, index?)' string\r\n      const [valueName, keyName, indexName] = params.replace('(', '').replace(')', '').split(',')\r\n      const trimmedValueName = valueName.trim()\r\n      const trimmedKeyName = keyName?.trim()\r\n      const trimmedIndexName = indexName?.trim()\r\n\r\n      Object.entries(evalExpr).forEach(([key, value], index) => {\r\n        const { newEl, newCtx } = createForItemCtx()\r\n\r\n        Object.assign(newCtx.data, { [trimmedValueName]: value })\r\n\r\n        if (trimmedKeyName)\r\n          Object.assign(newCtx.data, { [trimmedKeyName]: key })\r\n\r\n        if (trimmedIndexName)\r\n          Object.assign(newCtx.data, { [trimmedIndexName]: Number(index) })\r\n\r\n        appendAndWalkItem(newEl, newCtx)\r\n      })\r\n    }\r\n\r\n    else if (import.meta.env.DEV) {\r\n      throw new TypeError('Unsupported value was used in \\'x-for\\'. Please only use a number, array or an object')\r\n    }\r\n  })\r\n}\r\n","import { getAttr } from '../helpers'\r\nimport { applyDirectives } from '../walker'\r\nimport { processTextNode } from '../text-node'\r\nimport type { Directive } from './directives'\r\n\r\n// REVIEW\r\n// Should the target have mutation attached observer attached?\r\n\r\nexport const processPortal: Directive = function (ctx, original, { name, value }) {\r\n  // Clone node, teleport clone to the new place, replace current node\r\n  const clone = original.cloneNode(true) as HTMLElement\r\n  const target = document.querySelector(value)\r\n  const [, elPlacement] = name.split(':')\r\n\r\n  if (!target) {\r\n    // Shouldn't throw, as targets can be removed at runtime\r\n    console.error('No valid target provided for `x-portal`')\r\n    return\r\n  }\r\n\r\n  // Remove original node and append clone to the target\r\n  original.remove()\r\n\r\n  if (elPlacement === 'prepend')\r\n    target.prepend(clone)\r\n  else if (elPlacement === 'replace')\r\n    target.replaceChildren(clone)\r\n  else\r\n    target.append(clone)\r\n\r\n  // Walk the new branch. This code is a compressed clone of the\r\n  // `walk()` function with some differences which aren't necessarily\r\n  // worth an abstraction\r\n  const walker = document.createTreeWalker(clone)\r\n  let node: Node | null = walker.root\r\n\r\n  while (node) {\r\n    if (node.nodeType === Node.ELEMENT_NODE) {\r\n      const _node = node as HTMLElement\r\n\r\n      if (getAttr(_node, 'x-skip') !== null) {\r\n        node = walker.nextSibling()\r\n        continue\r\n      }\r\n\r\n      if (applyDirectives(ctx, _node)) {\r\n        node = walker.nextSibling()\r\n        continue\r\n      }\r\n    }\r\n    else if (node.nodeType === Node.TEXT_NODE) {\r\n      processTextNode(ctx, node)\r\n    }\r\n\r\n    node = walker.nextNode()\r\n  }\r\n}\r\n","import { evaluate } from '../evaluate'\r\nimport { isObj } from '../helpers'\r\nimport type { Directive } from './directives'\r\n\r\nfunction throwDataErr() {\r\n  throw new Error('[x-scope/x-data] Error when processing attribute. \\n Most likely an issue with the the data object.')\r\n}\r\n\r\nexport const processData: Directive<boolean> = function (ctx, node, { name, value }) {\r\n  node.removeAttribute(name)\r\n\r\n  if (name === 'x-scope' && ctx.root !== node)\r\n    throw new Error('Can not initialize a new scope within an existing scope')\r\n\r\n  try {\r\n    if (!value)\r\n      value = '{ }'\r\n\r\n    const data = evaluate({}, value)\r\n\r\n    if (!isObj(data))\r\n      throwDataErr()\r\n\r\n    for (const key of Object.keys(data)) {\r\n      Object.defineProperty(ctx.data, key, {\r\n        value: data[key],\r\n        writable: true,\r\n        enumerable: true,\r\n        configurable: true,\r\n      })\r\n    }\r\n  }\r\n  catch (e) {\r\n    console.warn('[x-scope/x-data] Error when processing attribute')\r\n    // console.log(e)\r\n    throwDataErr()\r\n  }\r\n\r\n  return false\r\n}\r\n","import { parseValue } from '../helpers'\r\nimport { walk } from '../walker'\r\nimport type { Directive } from './directives'\r\n\r\ninterface Block {\r\n  isDefault: boolean\r\n  isCase: boolean\r\n  expr: string | null\r\n  node: Element\r\n}\r\n\r\nexport const processSwitch: Directive = function (ctx, node, { value }) {\r\n  node.removeAttribute('x-switch')\r\n\r\n  // Since each case/default can be separated by normal non-switch\r\n  // nodes, we need to replace each with a commenet anchor so we can\r\n  // re-add it to the DOM in the right place\r\n  const anchors: Comment[] = []\r\n\r\n  // Get all child elements which are part of the switch statement\r\n  const blocks = Array\r\n    .from(node.children)\r\n    // Discard nodes which aren't part of the switch\r\n    .filter(c => c.hasAttribute('x-case') || c.hasAttribute('x-default'))\r\n    // Format into a block holding an expression and dom reference\r\n    .map((el): Block => {\r\n      return {\r\n        isDefault: el.hasAttribute('x-default'),\r\n        isCase: el.hasAttribute('x-case'),\r\n        expr: el.attributes.getNamedItem('x-case')?.value ?? null,\r\n        node: el,\r\n      }\r\n    })\r\n    // Remove all nodes from the DOM, they will be reattached based on\r\n    // the expression\r\n    .map((block) => {\r\n      // Insert comment before each node (there can be gaps between cases)\r\n      const anchor = new Comment('x-switch')\r\n      node.insertBefore(anchor, block.node)\r\n      // e.node.insertAdjacentElement('afterend', anchor)\r\n      anchors.push(anchor)\r\n      // Remove beskydy attributes and self\r\n      block.node.removeAttribute('x-case')\r\n      block.node.removeAttribute('x-default')\r\n      block.node.remove()\r\n      return block\r\n    })\r\n\r\n  let currentResult: Block | null\r\n\r\n  function clear() {\r\n    if (currentResult) {\r\n      currentResult.node.remove()\r\n      currentResult = null\r\n    }\r\n  }\r\n\r\n  ctx.effect(() => {\r\n    const result = ctx.eval(value)\r\n    let res: [Block, number] | undefined\r\n\r\n    for (let i = 0; i < blocks.length; i++) {\r\n      const block = blocks[i]\r\n\r\n      // If default is NOT last, we save it in case the following expression are not the result\r\n      if (i < blocks.length - 1 && block.isDefault)\r\n        res = [block, i]\r\n\r\n      if (block.expr) {\r\n        const blockResult = parseValue(block.expr, ctx)\r\n\r\n        if (blockResult === result) {\r\n          res = [block, i]\r\n          break\r\n        }\r\n      }\r\n      else if (i === blocks.length - 1) {\r\n        // We can expect we hit a `x-case` if we are on the last index and\r\n        // block is missing expression\r\n        res = [block, i]\r\n      }\r\n    }\r\n\r\n    if (res) {\r\n      clear()\r\n      const [block, index] = res\r\n      const anchor = anchors[index]\r\n      node.insertBefore(block.node, anchor)\r\n      walk(ctx, block.node)\r\n      currentResult = block\r\n      return\r\n    }\r\n\r\n    clear()\r\n  })\r\n}\r\n","import type { ContextAny } from '../context'\r\nimport type { Directive } from './directives'\r\n\r\n/**\r\n * Runs provided callback each time the context dataset is updated\r\n */\r\nexport const processSpy: Directive = function (ctx, node, { name, value }) {\r\n  // Check wether we are spyng on specific keys in the context dataset\r\n  const [_, ...spyOnParams] = name.split(':')\r\n\r\n  // let firstFired = false\r\n\r\n  // Store previously saved dataset to compare values when we're spying on specific properties\r\n  let previousData: ContextAny['data'] = Object.create(null)\r\n\r\n  ctx.effect(() => {\r\n    // Ignore first fire as that's when the scope is registered\r\n    // if (!firstFired) {\r\n    //   firstFired = true\r\n    //   return\r\n    // }\r\n\r\n    if (spyOnParams.length > 0) {\r\n      for (const key of spyOnParams) {\r\n        if (Reflect.get(previousData, key) !== Reflect.get(ctx.data, key)) {\r\n          ctx.eval(value, node)\r\n          break\r\n        }\r\n      }\r\n\r\n      previousData = { ...ctx.data }\r\n    }\r\n    else {\r\n      ctx.eval(value, node)\r\n    }\r\n  })\r\n}\r\n","import type { Directive } from '..'\r\n\r\n// Simply runs the provided expression\r\n// This is used for lifecycle methods\r\n// `x-init` = runs when all data is registered\r\n// `x-mount` = runs when all other directives have been processed\r\nexport const processLifecycle: Directive = (ctx, node, attr) => {\r\n  node.removeAttribute(attr.name)\r\n  ctx.eval(attr.value, node)\r\n}\n","import { getAttr, getElementIndex } from './helpers'\r\nimport type { ContextAny } from './context'\r\nimport { processRef } from './directives/x-ref'\r\nimport { processText } from './directives/x-text'\r\nimport { processStyle } from './directives/x-style'\r\nimport { processShow } from './directives/x-show'\r\nimport { processHTML } from './directives/x-html'\r\nimport { processBind } from './directives/x-bind'\r\nimport { processClass } from './directives/x-class'\r\nimport { processOn } from './directives/x-on'\r\nimport { processIf } from './directives/x-if'\r\nimport { processModel } from './directives/x-model'\r\nimport { processFor } from './directives/x-for'\r\nimport { processPortal } from './directives/x-portal'\r\nimport { processTextNode } from './text-node'\r\nimport { processData } from './directives/x-data'\r\nimport { processSwitch } from './directives/x-switch'\r\nimport { processSpy } from './directives/x-spy'\r\nimport { processLifecycle } from './directives/x-lifecycle'\r\n\r\nexport async function walk(ctx: ContextAny, forcedRoot?: Element) {\r\n  const rootEl = forcedRoot ?? ctx.root\r\n  let walker = document.createTreeWalker(rootEl)\r\n  let node: Node | null = walker.root\r\n\r\n  // Before we process directives, we first iterate over any data\r\n  // defining elements This will make sure that all the data objects are\r\n  // available to all elements within a scope/ That means we can\r\n  // reference a variable before it is defined.\r\n\r\n  // This approach might be against javascript conventions, but it is\r\n  // important to remember that the nesting of elements should not\r\n  // matter when usiny Beskydy. Each x-scope and all its descendants\r\n  // should be treated as a single, flat \"scope\".\r\n\r\n  const rootDatasets = (rootEl).querySelectorAll('[x-data]')\r\n  const rootScopeAttr = (rootEl).getAttributeNode('x-scope')\r\n\r\n  if (rootScopeAttr)\r\n    processData(ctx, rootEl, rootScopeAttr)\r\n\r\n  for (const rootDataset of rootDatasets) {\r\n    // We can ignore the fact that getAttributeNode can return null, as\r\n    // all the iterated elements have explicitly been queried by the\r\n    // `x-data` attribute\r\n    processData(ctx, rootDataset, rootDataset.getAttributeNode('x-data')!)\r\n  }\r\n\r\n  /// /////////////////////\r\n\r\n  while (node) {\r\n    switch (node.nodeType) {\r\n      case Node.ELEMENT_NODE: {\r\n        // Element\r\n        const _node = node as HTMLElement\r\n\r\n        // SECTION x-skip\r\n        // Elements with x-skip will be skipped during evaluation. The\r\n        // skip includes all elements children. Selects the next sibling.\r\n        if (getAttr(_node, 'x-skip') !== null) {\r\n          node = walker.nextSibling()\r\n          continue\r\n        }\r\n\r\n        // SECTION x-portal\r\n        // A section of DOM disconnected from the context\r\n        // tree but still within the reactive scope. We essentially need\r\n        // to create another walker within this walker to temporarily\r\n        // traverse the detached dom tree\r\n        let portalAttr\r\n        if (portalAttr = Array.from(_node.attributes).find(a => a.name.startsWith('x-portal')))\r\n          processPortal(ctx, _node, portalAttr)\r\n\r\n        // If appliy directives returns true, we want to skip to the next\r\n        // sibling instead of going deeper. This requires creating a new walker\r\n        // because the DOM has changed after using x-if/x-for.\r\n\r\n        // Save node index\r\n        const nodeIndex = getElementIndex(node)\r\n\r\n        if (applyDirectives(ctx, _node)) {\r\n          const tempWalker = document.createTreeWalker(rootEl)\r\n          let tempNode: Node | null = tempWalker.root\r\n          // Iterate until we are left off where the last walker ended (on the index)\r\n          let i = 0\r\n          while (tempNode && i !== nodeIndex) {\r\n            tempNode = tempWalker.nextNode()\r\n            i++\r\n          }\r\n\r\n          walker = tempWalker\r\n          node = tempWalker.currentNode\r\n\r\n          continue\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case Node.TEXT_NODE: {\r\n        // SECTION Text Node\r\n        // 1. Save string\r\n        // 2. Extract expression\r\n        // 3. Replace entire content between delimiters with the result of the expression\r\n        processTextNode(ctx, node)\r\n        break\r\n      }\r\n    }\r\n\r\n    node = walker.nextNode()\r\n  }\r\n}\r\n\r\n// Can be re-run on sub-sequent dom changes\r\nexport function applyDirectives(ctx: ContextAny, node: HTMLElement): boolean | void {\r\n  for (const attr of Array.from(node.attributes)) {\r\n    // REVIEW\r\n    // Unsure if the order of attribute processing is correct,\r\n    // but so far it hasn't posed any issues. Just adding this here so\r\n    // later we do a real review\r\n\r\n    // When scope has had its data registered, we can execute the init hook\r\n    if (attr.name === 'x-init') {\r\n      processLifecycle(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    // In case if and for are on the same element, the if is removed.\r\n    if (attr.name === 'x-for') {\r\n      processFor(ctx, node, attr)\r\n\r\n      return true\r\n    }\r\n    else if (attr.name === 'x-if') {\r\n      const shouldSkipNode = processIf(ctx, node, attr)\r\n\r\n      // This looks wonky, but we only want to return a value if the\r\n      // sibling should be skipped. If not, we want this function to\r\n      // continue further.\r\n      if (shouldSkipNode) {\r\n        // REVIEW: ive no fucking clue man\r\n        return true\r\n      }\r\n\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-switch') {\r\n      processSwitch(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-ref') {\r\n      processRef(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name.startsWith('x-model')) {\r\n      processModel(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name.startsWith('x-bind') || attr.name.startsWith(':')) {\r\n      processBind(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name.startsWith('@') || attr.name.startsWith('x-on')) {\r\n      processOn(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name.startsWith('x-spy')) {\r\n      processSpy(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-text') {\r\n      processText(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-class') {\r\n      processClass(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-html') {\r\n      processHTML(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-style') {\r\n      processStyle(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-show') {\r\n      processShow(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    // Custom directive implementation\r\n    const keys = Object.keys(ctx.app.customDirectives)\r\n\r\n    if (keys.length > 0) {\r\n      for (const key of keys) {\r\n        const directive = ctx.app.customDirectives[key]\r\n        if (attr.name.startsWith(key))\r\n          directive(ctx, node, attr)\r\n      }\r\n    }\r\n\r\n    // When scope has had its data registered, we can execute the init hook\r\n    if (attr.name === 'x-processed') {\r\n      processLifecycle(ctx, node, attr)\r\n      continue\r\n    }\r\n  }\r\n}\r\n","import type { UnwrapNestedRefs } from '@vue/reactivity'\r\nimport { reactive } from '@vue/reactivity'\r\nimport type { ContextAny } from './context'\r\nimport { Context } from './context'\r\nimport type { Directive, EventModifierFn } from './directives/directives'\r\nimport { walk } from './walker'\r\nimport { eventModifiers } from './directives/x-on'\r\nimport type { ModelModifierFn } from './directives/x-model'\r\nimport { modelModifiers } from './directives/x-model'\r\n\r\n// Custom modifiers warning message, which is shared across all three of them\r\nconst warnEnd = 'is a reserved name or its already been defined. Please use a different name.'\r\ntype Cb = () => void\r\n\r\nfunction escapeRegex(str: string) {\r\n  return str.replace(/[-.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&')\r\n}\r\n\r\nfunction createDelimiterRegex(start: string, end: string) {\r\n  return new RegExp(\r\n    `${escapeRegex(start)}([^]+?)${escapeRegex(end)}`,\r\n    'g',\r\n  )\r\n}\r\n\r\nexport class Beskydy<T extends object> {\r\n  modelModifiers: Record<string, ModelModifierFn>\r\n  eventModifiers: Record<string, EventModifierFn>\r\n  customDirectives: Record<string, Directive>\r\n  delimiters: {\r\n    start: string\r\n    end: string\r\n    re: RegExp\r\n  }\r\n\r\n  private scopes: ContextAny[]\r\n  rootState: UnwrapNestedRefs<T>\r\n  private onInitCbs: Cb[]\r\n  private onTeardownCbs: Cb[]\r\n\r\n  constructor(initialDataset?: T) {\r\n    this.modelModifiers = Object.assign({}, modelModifiers)\r\n    this.eventModifiers = Object.assign({}, eventModifiers)\r\n    this.customDirectives = {}\r\n    this.delimiters = {\r\n      start: '{{',\r\n      end: '}}',\r\n      re: createDelimiterRegex('{{', '}}'),\r\n    }\r\n    this.scopes = []\r\n    this.rootState = reactive(Object.assign({}, initialDataset))\r\n    this.onInitCbs = []\r\n    this.onTeardownCbs = []\r\n  }\r\n\r\n  /**\r\n   * Define the way Beskydy will compile the delimiters {{ }} into a reactive part of a string.\r\n   * Delimiters contain text, which usually contains an expression. Think of it was as javascript being executed within a string when it is wrapped in the delimiters {{ }}\r\n   *\r\n   *\r\n   * @param start Starting delimiter\r\n   * @param end Ending delimiter\r\n   */\r\n  setDelimiters(start: string, end: string) {\r\n    if (start === '{' || end === '}')\r\n      console.warn('You are using {} as delimiters, please keep in mind that you will not be able to use template literals inside of them.')\r\n    this.delimiters = { start, end, re: createDelimiterRegex(start, end) }\r\n  }\r\n\r\n  /**\r\n   * Add a custom directive (element attribute)\r\n   *\r\n   * @param name Directive name, preferably should start with `x-`\r\n   * @param fn Directive implementation\r\n   */\r\n  defineDirective(name: string, fn: Directive) {\r\n    if (name in this.customDirectives)\r\n      throw new Error(`The directive \"${name}\" ${warnEnd}`)\r\n    this.customDirectives[name] = fn\r\n  }\r\n\r\n  /**\r\n   * Add a custom `x-on` event modifier\r\n   *\r\n   * @param name Modifier name\r\n   * @param fn Modifier implementation\r\n   */\r\n  defineEventModifier(name: string, fn: EventModifierFn) {\r\n    if (name in this.eventModifiers)\r\n      throw new Error(`The event modifier \"${name}\" ${warnEnd}`)\r\n    this.eventModifiers[name] = fn\r\n  }\r\n\r\n  /**\r\n   * Add a custom `x-model` modifier\r\n   *\r\n   * @param name Modifier name\r\n   * @param fn Modifier implementation\r\n   */\r\n  defineModelModifier(name: string, fn: ModelModifierFn) {\r\n    if (name in this.modelModifiers)\r\n      throw new Error(`The model modifier \"${name}\" ${warnEnd}`)\r\n    this.modelModifiers[name] = fn\r\n  }\r\n\r\n  /**\r\n   *  Initialize Beskydy. It starts by collecting all the scope elements\r\n   *  and creating a context for each.\r\n   *\r\n   * @param selector Custom attribute selector. Defaults to 'x-scope'\r\n   */\r\n  collect(selector: string = '[x-scope]') {\r\n    const scopeRoots = Array.from(document.querySelectorAll(selector))\r\n    if (scopeRoots.length === 0)\r\n      console.warn(`No scopes were found for the selector \"${selector}\". Make sure to define at least one.`)\r\n\r\n    for (const scopeRoot of scopeRoots) {\r\n      const ctx = new Context(scopeRoot, this, {})\r\n      // Hide scope until it's initialized\r\n      scopeRoot.setAttribute('style', 'display:none;')\r\n      walk(ctx)\r\n      ctx.init = true\r\n      scopeRoot.removeAttribute('style')\r\n      this.scopes.push(ctx)\r\n    }\r\n\r\n    for (const cb of this.onInitCbs)\r\n      cb()\r\n  }\r\n\r\n  /**\r\n   * Registers a function which runs when app is fully initialized\r\n   */\r\n  onInit(fn: Cb) {\r\n    this.onInitCbs.push(fn)\r\n  }\r\n\r\n  /**\r\n   * Registers a callback which runs after application has been shut down\r\n   */\r\n  onTeardown(fn: Cb) {\r\n    this.onTeardownCbs.push(fn)\r\n  }\r\n\r\n  /**\r\n   *   Stops Beskydy instance, removes reactivity and event listeners\r\n   *   and leaves the DOM in the state it was when the app was torn down.\r\n   */\r\n  teardown() {\r\n    for (const ctx of this.scopes)\r\n      ctx.teardown()\r\n\r\n    this.scopes.length = 0\r\n\r\n    // REVIEW\r\n    // Should the onTeardown callbacks run before teardown or right after?\r\n    for (const cb of this.onTeardownCbs)\r\n      cb()\r\n  }\r\n}\r\n","import { Beskydy } from './beskydy'\r\nimport type { Directive, EventModifierFn, Primitive } from './directives/directives'\r\nimport type { ModelModifierFn } from './directives/x-model'\r\n\r\nexport {\r\n  Beskydy,\r\n  Directive,\r\n  Primitive,\r\n  EventModifierFn,\r\n  ModelModifierFn,\r\n}\r\n\r\n//////////////////////////////////////////////\r\n\r\nconst app = new Beskydy({\r\n  selected: 'people',\r\n  loading: false,\r\n  data: [],\r\n  fetchData() {\r\n    this.loading = true\r\n    fetch(`https://swapi.dev/api/${this.selected}`)\r\n      .then(r => r.json())\r\n      .then((r) => {\r\n        this.data = r.results\r\n      })\r\n      .finally(() => {\r\n        this.loading = false\r\n      })\r\n  },\r\n  // makeElement() {\r\n  //   return document.createElement(\"table\")\r\n  // }\r\n})\r\n\r\n// app.defineDirective('x-three', (ctx, el, attr) => {\r\n//   ctx.effect(() => {\r\n//     const value: number = ctx.eval(attr.value)\r\n\r\n//     if (value % 3 === 0) {\r\n//       el.textContent = \"DIVISIBLE BY THREE!!!\"\r\n//     } else {\r\n//       el.textContent = String(value)\r\n//     }\r\n//   })\r\n// })\r\n\r\n// Modify the model value\r\n// app.defineModelModifier('maxlength', (value, prevValue, length: number) => {\r\n//   if (value.length > length)\r\n//     return prevValue\r\n//   return value\r\n// })\r\n\r\n// // Modify if event is registered\r\n// app.defineEventModifier('every', (_, state, param) => {\r\n//   return state.calledTimes % Number(param) === 0\r\n// })\r\n\r\napp.collect()\r\n"],"names":["evalCache","evaluate","scope","exp","el","execute","event","fn","toFunction","e","Context","root","app","initialDataset","__publicField","reactive","handler","rawEffect","key","ref","ctx","expr","clone","_a","getAttr","attr","isNil","value","isObj","isArr","removeChildren","node","parseValue","getElementIndex","child","i","processRef","name","toDisplayString","processTextNode","delimiters","originalTextContent","segments","lastIndex","match","leading","processText","processStyle","result","processShow","processHTML","processBind","_","propertyName","setOrDelAttr","results","processClass","assignObjectClasses","parsed","prevInlineResults","prevResult","previous","eventModifiers","lastCall","amount","__","rawEval","calledTimes","callLimit","processOn","eventKeyRaw","eventKey","modifiers","modifier","rawParams","param","parsedModifier","state","processIf","parent","anchor","blocks","elseEl","elseExpr","currentIndex","currentResult","clear","shouldGoNextSibling","index","block","walk","modelModifiers","prevValue","processModel","defaultValue","modify","newValue","oldValue","assignSimpleDefaultValue","finalValue","modelValue","setCheckboxValue","checked","evt","target","rawValue","modifiedValue","val","defaultOpen","currentValue","isOpen","processFor","params","originalNode","createForItemCtx","newEl","newCtx","appendAndWalkItem","evalExpr","valueName","indexName","trimmedValueName","trimmedIndexName","item","keyName","trimmedKeyName","processPortal","original","elPlacement","walker","_node","applyDirectives","throwDataErr","processData","data","processSwitch","anchors","c","res","processSpy","spyOnParams","previousData","processLifecycle","forcedRoot","rootEl","rootDatasets","rootScopeAttr","rootDataset","portalAttr","a","nodeIndex","tempWalker","tempNode","keys","directive","warnEnd","escapeRegex","str","createDelimiterRegex","start","end","Beskydy","selector","scopeRoots","scopeRoot","cb","r"],"mappings":"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"}