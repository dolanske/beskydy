{"version":3,"file":"beskydy.js","sources":["../src/evaluate.ts","../src/context.ts","../src/helpers.ts","../src/directives/x-ref.ts","../src/text-node.ts","../src/directives/x-text.ts","../src/directives/x-style.ts","../src/directives/x-show.ts","../src/directives/x-html.ts","../src/directives/x-bind.ts","../src/directives/x-class.ts","../src/directives/x-on.ts","../src/directives/x-if.ts","../src/directives/x-model.ts","../src/directives/x-for.ts","../src/directives/x-portal.ts","../src/directives/x-data.ts","../src/directives/x-switch.ts","../src/directives/x-spy.ts","../src/directives/x-lifecycle.ts","../src/walker.ts","../src/beskydy.ts","../src/index.ts"],"sourcesContent":["/**\n * Thank you so much Evan You, I love you\n */\n\nconst evalCache: Record<string, Function> = Object.create(null)\n\nexport function evaluate(scope: any, exp: string, el?: Node) {\n  return execute(scope, `return(${exp})`, el)\n}\n\nexport function execute(scope: any, exp: string, el?: Node, event?: Event) {\n  // By calling stringify, the function hits every single property within an\n  // object. No matter how deep it is. This way we can ensure deep reactivity\n  // Thanks to Alpine.js core for the tip\n  JSON.stringify(scope)\n\n  const fn = evalCache[exp] || (evalCache[exp] = toFunction(exp))\n  try {\n    return fn(scope, el, event)\n  }\n  catch (e) {\n    if (import.meta.env.DEV) {\n      // console.log(scope)\n      console.warn(`Error when evaluating expression \"${exp}\":`)\n    }\n    console.error(e)\n  }\n}\n\nfunction toFunction(exp: string): Function {\n  try {\n    // eslint-disable-next-line no-new-func\n    return new Function('data', '$el', '$event', `with(data){${exp}}`)\n  }\n  catch (e) {\n    console.error(`${(e as Error).message} in expression: ${exp}`)\n    return () => { }\n  }\n}\n","import type { ReactiveEffectRunner, UnwrapNestedRefs } from '@vue/reactivity'\nimport { effect as rawEffect, reactive } from '@vue/reactivity'\nimport type { Beskydy } from './beskydy'\nimport { evaluate } from './evaluate'\n\nexport type ContextAny = Context<Element, Beskydy<object>, object>\n\n// Piece of DOM which holds its own state. This class can be used on its\n// own, but requires an instance of Beskydy to provide modifiers to a\n// few directives.\n\n// In case you want to create custom context, you can just do:\n// const ctx = new Context(root, new Beskydy())\n\nexport class Context<R extends Element, A extends Beskydy<object>, T extends object> {\n  // Store the context's root element\n  root: Element\n  // Reactive dataset available to the entire scope\n  data: UnwrapNestedRefs<T & { $refs: Record<string, Element> }>\n  init: boolean\n  // Hold all context runners for disposal\n  effects: ReactiveEffectRunner[] = []\n\n  // Stores a referene to the root app instance\n  app: Beskydy<object>\n\n  constructor(root: R, app: A, initialDataset?: T) {\n    this.root = root\n    this.data = reactive(Object.assign({ $refs: {} }, app.rootState, initialDataset))\n    this.init = false\n    this.app = app\n  }\n\n  /**\n   * Executes the provided callback fn whenever the context's reactive\n   * dataset updates\n   *\n   * @param fn Callback\n   */\n  effect(fn: () => any) {\n    const handler = rawEffect(fn)\n    this.effects.push(handler)\n  }\n\n  /**\n   * Stores a reference to a DOM element by the provided key. This\n   * allows us to use $refs object within expressions\n   *\n   * @param key Ref key\n   * @param ref Element\n   */\n  addRef(key: string, ref: Element) {\n    Object.assign(this.data.$refs, { [key]: ref })\n  }\n\n  /**\n   * When creating sub contexts, this allows for a parent context to\n   * share its reactive properties with the child context\n   *\n   * @param ctx Context\n   */\n  extend(ctx: ContextAny) {\n    Object.assign(this.data, ctx.data)\n  }\n\n  /**\n   * Evaluates the provided expression against the context dataset\n   *\n   * @param expr Expression\n   * @param el Optionally, make the current element available as $el\n   * @returns Evaluated value\n   */\n  eval(expr: string, el?: Node | undefined) {\n    return evaluate(this.data, expr, el)\n  }\n\n  /**\n   * Turns the scope's elements to the original static HTML. Removes\n   * event listeners and stops reactive watchers.\n   */\n  teardown() {\n    // Iterate over all children of a ctx and remove any beskydy functionality\n    this.effects.forEach(e => e.effect.stop())\n    this.effects.length = 0\n\n    // Clone whole subtree and re-attach it to the parent. This removes any event listeners\n    const clone = this.root.cloneNode(true)\n    this.root.parentElement?.replaceChild(clone, this.root)\n\n    // Overwrite context dataset with an empty object\n    Reflect.set(this, 'data', Object.create(null))\n\n    this.init = false\n  }\n}\n","import type { Primitive } from './directives/directives'\nimport type { ContextAny } from './context'\nimport { evaluate } from './evaluate'\n\nexport function isSibling(el: HTMLElement, el2: HTMLElement) {\n  return el !== el2 && el.parentNode === el2.parentNode\n}\n\nexport function getAttr(el: HTMLElement | Element, key: string) {\n  const attr = el.attributes.getNamedItem(key)\n  if (!attr)\n    return null\n  el.removeAttribute(key)\n  return attr.value ?? true\n}\n\nexport function isNil(value: unknown) {\n  return value === undefined || value === null\n}\n\nexport function isObj(value: unknown) {\n  return (!!value) && (value.constructor === Object)\n}\n\nexport const isArr = Array.isArray\n\nexport const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\n\nexport function removeChildren(node: Element) {\n  while (node.lastElementChild)\n    node.removeChild(node.lastElementChild)\n}\n\nexport function isType(val: any, requiredType: Primitive) {\n  // eslint-disable-next-line valid-typeof\n  return typeof val === requiredType\n}\n\nexport function parseValue(value: string, ctx: ContextAny): Primitive {\n  if (value in ctx.data) {\n    return evaluate(ctx.data, value)\n  }\n  else {\n    if (value === 'undefined')\n      return undefined\n    else if (value === 'null')\n      return null\n    else if (value === 'true' || value === 'false')\n      return Boolean(value)\n    // eslint-disable-next-line unicorn/prefer-number-properties\n    else if (!isNaN(value as any))\n      return Number(value)\n    else\n      return value\n  }\n}\n\n/**\n * Execute given callback on the next browser repaint. It also returns a\n * promise, so instead of a callback, it can be awaited.\n *\n * @param callback\n * @returns Promise\n */\nexport function nextTick(callback?: () => void) {\n  return new Promise((resolve) => {\n    requestAnimationFrame(() => {\n      if (callback)\n        callback()\n      resolve(true)\n    })\n  })\n}\n\nexport function getElementIndex(child: Node | null): number {\n  let i = 0\n  while ((child = child!.previousSibling) != null)\n    i++\n\n  return i\n}\n","import type { Directive } from './directives'\n\nexport const processRef: Directive = function (ctx, node, { value, name }) {\n  node.removeAttribute(name)\n  // Add ref once\n  ctx.addRef(value, node)\n\n  // Update whenever ref's items are changed\n  const mo = new MutationObserver(() => {\n    ctx.addRef(value, node)\n  })\n\n  mo.observe(node, {\n    attributes: true,\n    childList: true,\n    subtree: true,\n    characterData: true,\n  })\n}\n","import type { ContextAny } from './context'\nimport { evaluate } from './evaluate'\nimport { isObj } from './helpers'\n\nexport function toDisplayString(value: any) {\n  return value == null\n    ? ''\n    : isObj(value)\n      ? JSON.stringify(value, null, 2)\n      : String(value)\n}\n\nexport function processTextNode(ctx: ContextAny, node: Node) {\n  // This should never be hit as only text nodes are processed, but\n  // typescript is a known crybaby\n  if (!node.textContent || node.textContent.trim().length === 0)\n    return\n\n  const delimiters = ctx.app.delimiters\n\n  // Save the original expression\n  const originalTextContent = node.textContent\n\n  ctx.effect(() => {\n    // const data = (node as Text).data\n    if (originalTextContent.includes(delimiters.start)) {\n      const segments: string[] = []\n      let lastIndex = 0\n      let match\n      while ((match = delimiters.re.exec(originalTextContent))) {\n        const leading = originalTextContent.slice(lastIndex, match.index)\n        if (leading)\n          segments.push(JSON.stringify(leading))\n        segments.push(toDisplayString(`${match[1]}`))\n        lastIndex = match.index + match[0].length\n      }\n      if (lastIndex < originalTextContent.length)\n        segments.push(JSON.stringify(originalTextContent.slice(lastIndex)))\n\n      node.textContent = evaluate(ctx.data, segments.join('+'))\n    }\n    else {\n      node.textContent = toDisplayString(originalTextContent)\n    }\n  })\n}\n","import { toDisplayString } from '../text-node'\nimport type { Directive } from './directives'\n\nexport const processText: Directive = function (ctx, node, { name, value }) {\n  node.removeAttribute(name)\n  const expr = value\n  ctx.effect(() => {\n    node.textContent = toDisplayString(ctx.eval(expr, node))\n  })\n}\n","import { isObj } from '../helpers'\nimport type { Directive } from './directives'\n\nexport const processStyle: Directive = function (ctx, node, { value, name }) {\n  node.removeAttribute(name)\n\n  const expr = value\n\n  ctx.effect(() => {\n    const result = ctx.eval(expr, node)\n\n    if (!isObj(result))\n      return\n\n    for (const key of Object.keys(result)) {\n      // If it's a non HTMLElement node, skip it\n      if (!Reflect.has(node, 'style'))\n        continue\n\n      // Using reflect set allows us using camelCase and kebab-case styles\n      Reflect.set((node as HTMLElement).style, key, result[key])\n    }\n  })\n}\n","import type { Directive } from './directives'\n\n/**\n * Takes in and evaluates an expression. Based on the result the element\n * is either shown or hidden in the DOM.\n */\nexport const processShow: Directive = function (ctx, node, { value, name }) {\n  node.removeAttribute(name)\n\n  const expr = value\n\n  if (!Reflect.has(node, 'style'))\n    return\n\n  ctx.effect(() => {\n    const result = ctx.eval(expr, node)\n    if (result)\n      (node as HTMLElement).style.removeProperty('display')\n    else\n      (node as HTMLElement).style.setProperty('display', 'none')\n  })\n}\n","import type { Directive } from './directives'\n\nexport const processHTML: Directive = function (ctx, node, { value, name }) {\n  node.removeAttribute(name)\n  const expr = value\n  ctx.effect(() => {\n    const result = ctx.eval(expr, node)\n\n    if (result instanceof Element) {\n      node.replaceChildren()\n      node.append(result)\n    }\n    else {\n      node.innerHTML = result\n    }\n  })\n}\n","import { isNil } from '../helpers'\nimport type { Directive } from './directives'\n\n/**\n * Dynamically bind attribute or attributes if the expression passes\n *\n * Allowed syntax\n *\n * This syntax will bind a value-less attribute (boolean attribute) if the expression matches\n * - :attributeName=\"expression\"\n * - x-bind:attributeName=\"expression\"\n * - x-bind=\"{ attributeValue: expression }\"\n */\nexport const processBind: Directive = function (ctx, node, { name, value }) {\n  node.removeAttribute(name)\n\n  const [_, propertyName] = name.split(':')\n\n  const setOrDelAttr = (key: string, value: any) => {\n    // If no value is provided or the value is a boolean, remove the\n    // attribute instead of simply setting it to the value.\n\n    // The reason for that is disabled=\"false\" will still disable the\n    // attribute, as boolean attributes dont care about the value\n    if (isNil(value) || value === false)\n      node.removeAttribute(key)\n    else\n      node.setAttribute(key, value)\n  }\n\n  if (propertyName) {\n    // x-bind:propertyName=\"\" syntax\n    ctx.effect(() => {\n      const result = ctx.eval(value, node)\n      setOrDelAttr(propertyName, result)\n    })\n  }\n  else {\n    // x-bind=\"{}\" syntax\n    ctx.effect(() => {\n      const results = ctx.eval(value, node) ?? {}\n\n      for (const key of Object.keys(results)) {\n        const result = results[key]\n        setOrDelAttr(key, result)\n      }\n    })\n  }\n}\n","import { isObj } from '../helpers'\nimport type { Directive } from './directives'\n\nexport const processClass: Directive = function (ctx, node, { value }) {\n  const assignObjectClasses = (parsed: Record<string, unknown>) => {\n    for (const key of Object.keys(parsed)) {\n      if (parsed[key])\n        node.classList.add(key)\n      else\n        node.classList.remove(key)\n    }\n  }\n\n  if (value.startsWith('[')) {\n    // Evaluate Should receive an array of strings or objects. Iterate on it and\n    // call either of the process functions\n    const prevInlineResults: Record<number, string | null> = Object.create(null)\n\n    ctx.effect(() => {\n      const results = ctx.eval(value)\n\n      for (let i = 0; i < results.length; i++) {\n        const result = results[i]\n\n        if (!result) {\n          const prevResult = prevInlineResults[i]\n\n          if (prevResult) {\n            node.classList.remove(prevResult)\n            prevInlineResults[i] = null\n          }\n        }\n        else if (typeof result === 'string') {\n          node.classList.add(result)\n          prevInlineResults[i] = result\n        }\n        else if (isObj(result)) {\n          assignObjectClasses(result)\n        }\n      }\n    })\n  }\n  else if (value.startsWith('{') && value.endsWith('}')) {\n    // Processes object expression. If the value is truthy, the key will be\n    // assigned as a classname\n    // Eg: { className: expression, display: isVisible }\n    ctx.effect(() => {\n      const parsed: Record<string, unknown> = ctx.eval(value, node)\n      assignObjectClasses(parsed)\n    })\n  }\n  else {\n    // Processes inline ternary operator expression\n    // Eg: \"value ? 'class' : null\"\n    let previous: string\n    ctx.effect(() => {\n      if (previous)\n        node.classList.remove(previous)\n\n      previous = ctx.eval(value, node)\n      node.classList.add(previous)\n    })\n  }\n}\n","import { execute } from '../evaluate'\nimport { parseValue } from '../helpers'\nimport type { Directive, EventModifierFn, Modifier, ModifierListenerState, Primitive } from './directives'\n\n// Default event modifiers which are bound to an app instance\nexport const eventModifiers: Record<string, EventModifierFn> = {\n  throttle: (_, { lastCall }, amount = 300) => {\n    if (typeof amount !== 'number')\n      return false\n    if (Date.now() - lastCall >= amount)\n      return true\n    return false\n  },\n  if: (_, __, rawEval) => !!rawEval,\n  only: (_, { calledTimes }, callLimit = 1) => {\n    if (typeof callLimit !== 'number')\n      return false\n    return calledTimes < callLimit\n  },\n  once: (_, { calledTimes }) => calledTimes < 1,\n  self: e => e.target === e.currentTarget,\n  left: e => 'button' in e && (e as MouseEvent).button === 0,\n  middle: e => 'button' in e && (e as MouseEvent).button === 1,\n  right: e => 'button' in e && (e as MouseEvent).button === 2,\n  prevent: (e) => {\n    e.preventDefault()\n    return true\n  },\n  stop: (e) => {\n    e.stopPropagation()\n    return true\n  },\n  stopImmediate: (e) => {\n    e.stopImmediatePropagation()\n    return true\n  },\n}\n\n/**\n * Binds an event listener with optional modifiers to the selected\n * element. The provided expression is evaluated whenever the event is\n * fired.\n */\nexport const processOn: Directive = function (ctx, node, { name, value }) {\n  node.removeAttribute(name)\n\n  // Get the event name and its modifiers. The two supported syntaxes\n  // for binding event listeners are using either `@event` or\n  // `x-on:event`. With optional modifiers appended by using\n  // `@event.modifier.modifier` etc\n  const eventKeyRaw = (name.startsWith('x-on') ? name.split(':')[1] : name.substring(1)).split('.')\n  const eventKey = eventKeyRaw[0]\n\n  // Collect optional modifiers from the event name\n  // (event.modifier.modifier) and filter out ones which aren't\n  // supported (aka user errors)\n  const modifiers: Modifier[] = eventKeyRaw\n    .slice(1)\n    .map((modifier) => {\n      // Split modifier into a key and possible parameter\n      // eventKey[param]=\"\"\n      const [key, rawParams] = modifier.split('[')\n      let param: Primitive\n\n      if (rawParams) {\n        const parsedModifier = rawParams.replace(']', '')\n        // The parameter can be a reactive variable.\n        // So we should evaluate it against the current context, but only if its available\n        param = parseValue(parsedModifier, ctx)\n      }\n\n      return { key, param }\n    })\n    .filter((modifier) => {\n      return Object.keys(ctx.app.eventModifiers).includes(modifier.key)\n    })\n\n  if (value.startsWith('('))\n    value = `(${value})()`\n\n  // State variables, which some of the modifiers use\n  const state: ModifierListenerState = {\n    calledTimes: 0,\n    lastCall: 0,\n  }\n\n  node.addEventListener(eventKey, (event: Event) => {\n    // Only execute callback if every modifier passes\n    if (modifiers.every(modifier => ctx.app.eventModifiers[modifier.key](event, state, modifier.param)))\n      execute(ctx.data, value, node, event)\n\n    state.calledTimes++\n    state.lastCall = Date.now()\n  })\n}\n","import { getAttr } from '../helpers'\nimport { walk } from '../walker'\nimport type { Directive } from './directives'\n\ninterface Block {\n  expr: string | null\n  node: HTMLElement\n}\n\n/**\n * Takes in an expression and based on its result, the elements are\n * either completely removed or (re)added to the DOM.\n *\n * The usage syntax and rules\n *  x-if        // Requires expression\n *  x-else-if   // Requires expression and adjacent x-if or x-if-else\n *  x-else      // Requires adjacent x-if or x-else\n */\n\nexport const processIf: Directive<boolean> = function (ctx, node, { name, value }) {\n  node.removeAttribute(name)\n\n  // Holds the reference to the element and its parent node\n  const parent = node.parentElement!\n\n  // This serves as an \"anchor\" to mount the element back in if the provided expression returns true\n  const anchor = new Comment('x-if')\n  parent.insertBefore(anchor, node)\n\n  // Store each element as a block with its expression\n  const blocks: Block[] = [{\n    node: node as HTMLElement,\n    expr: value,\n  }]\n\n  // Look for v-else-if and v-else elements and their expression\n  let elseEl: Element | null\n  let elseExpr: string | null\n  while ((elseEl = node.nextElementSibling) !== null) {\n    if ((elseExpr = getAttr(elseEl, 'x-else')) !== null || (elseExpr = getAttr(elseEl, 'x-else-if'))) {\n      blocks.push({\n        node: elseEl as HTMLElement,\n        expr: elseExpr,\n      })\n\n      // Remove them because they can be re-added during evaluation process\n      parent.removeChild(elseEl)\n    }\n    else {\n      // If the NEXT sibling does not contain one of these,\n      // stop checking. As only adjacent elements to the first\n      // x-if can be tied to it. Gaps aren't allowed\n      break\n    }\n  }\n\n  parent.removeChild(node)\n\n  let currentIndex: number\n  let currentResult: Block | null\n\n  function clear() {\n    if (currentResult) {\n      parent.removeChild(currentResult.node)\n      currentResult = null\n    }\n  }\n\n  // This is ran just once on initialization. If an x-if has just one\n  // node and it doesnt pass the initial evaluation, we should stop the\n  // walker from walking through the node tree. By returned true from\n  // this process, we'll tell the walker to skip this. It's like\n  // conditionally adding x-skip to this.\n  let shouldGoNextSibling = false\n\n  ctx.effect(() => {\n    // Iterate over each block and evaluate block expressions\n    for (let index = 0; index < blocks.length; index++) {\n      const block = blocks[index]\n\n      if (!block.expr || ctx.eval(block.expr, node)) {\n        // Passed\n        if (currentIndex !== index) {\n          if (currentResult)\n            clear()\n\n          parent.insertBefore(block.node, anchor)\n\n          // Walk and process again\n          walk(ctx, block.node)\n\n          currentResult = block\n          currentIndex = index\n        }\n        else {\n          shouldGoNextSibling = true\n        }\n\n        return\n      }\n      else {\n        shouldGoNextSibling = true\n      }\n    }\n\n    currentIndex = -1\n    clear()\n  })\n\n  return shouldGoNextSibling\n}\n","import { isArr, isNil, parseValue } from '../helpers'\nimport type { Directive, Primitive } from './directives'\n\nexport type ModelModifierFn = (value: string, oldValue: string, param?: any) => unknown\n\nexport const modelModifiers: Record<string, ModelModifierFn> = {\n  trim: (value: string) => value.trim(),\n  number: (value: string, prevValue: string) => {\n    if (Number.isNaN(Number(value)))\n      return Number(prevValue)\n\n    return Number(value)\n  },\n} as const\n\nexport type ModelElement = HTMLInputElement | HTMLSelectElement | HTMLDetailsElement | HTMLTextAreaElement\ntype Modifier = keyof typeof modelModifiers\n\nexport const processModel: Directive = function (ctx, el, { name, value }) {\n  let node = el as ModelElement\n  const [_, modifier] = name.split('.') as [unknown, Modifier]\n  const defaultValue = node.attributes.getNamedItem('value')?.value\n\n  // Call back to execute model modifiers and return the modified value\n  const modify = (newValue: string, oldValue: string) => {\n    if (!modifier)\n      return newValue\n\n    // Model param\n    const [key, rawParams] = modifier.split('[')\n    let param: Primitive\n\n    if (rawParams) {\n      const parsedModifier = rawParams.replace(']', '')\n      // The parameter can be a reactive variable.\n      // So we should evaluate it against the current context, but only if its available\n      param = parseValue(parsedModifier, ctx)\n    }\n\n    return ctx.app.modelModifiers[key](newValue, oldValue, param)\n  }\n\n  const assignSimpleDefaultValue = () => {\n    let finalValue\n    const modelValue = ctx.eval(value)\n\n    if (!modelValue) {\n      if (defaultValue)\n        finalValue = defaultValue\n    }\n    else {\n      finalValue = modelValue\n    }\n\n    Object.assign(ctx.data, { [name]: finalValue })\n    node = node as HTMLInputElement\n    node.value = finalValue\n  }\n\n  switch (node.tagName) {\n    case 'INPUT':\n    case 'TEXTAREA': {\n      node = node as HTMLInputElement\n\n      switch (node.type) {\n        // Listen for 'change' event\n        case 'checkbox': {\n          const modelValue = Reflect.get(ctx.data, value) as Array<any> | string | undefined | null\n\n          /**\n           * With checkbox, there are multiple cases\n           *  - no value:       we toggle checked state as a boolean\n           *  - value:          we toggle checked state as its value\n           *  - array no value: nothing, array of random booleans makes no sense\n           *  - array values:   push / splice out if checked or not\n           */\n\n          const setCheckboxValue = (value: string, checked: boolean) => {\n            // Selected but something else: ARRAY\n            if (isArr(modelValue)) {\n              if (modelValue.includes(value))\n                modelValue.splice(modelValue.indexOf(value), 1)\n              else\n                modelValue.push(value)\n            }\n            // Primitive\n            else {\n              Reflect.set(ctx.data, value, isNil(value) ? !checked : value)\n            }\n          }\n\n          // If no model value is provided and element contains checked, assign default value\n          if ((!modelValue || modelValue.length === 0) && node.hasAttribute('checked')) {\n            setCheckboxValue(node.value, true)\n            node.removeAttribute('checked')\n          }\n\n          node.addEventListener('change', (evt) => {\n            const { checked, value } = evt?.target as HTMLInputElement\n            setCheckboxValue(value, checked)\n          })\n\n          ctx.effect(() => {\n            node = node as HTMLInputElement\n            // Update in case some properties are removed or set elsewhere\n            const results = ctx.eval(value)\n\n            if (results.includes(node.value) || node.value === results)\n              node.checked = true\n            else\n              node.checked = false\n          })\n          break\n        }\n\n        // Listen for 'change' event\n        case 'radio': {\n          // Default value\n          if (node.hasAttribute('checked')) {\n            node.removeAttribute('checked')\n            Object.assign(ctx.data, { [value]: node.value })\n          }\n\n          node.addEventListener('change', (evt) => {\n            const { checked, value } = evt.target as HTMLInputElement\n            if (checked)\n              Object.assign(ctx.data, { [value]: value })\n          })\n\n          // If evaluated value changes, make sure to update the HTML as well\n          ctx.effect(() => {\n            node = node as HTMLInputElement\n            const newValue = ctx.eval(value)\n            node.checked = node.value === newValue\n          })\n          break\n        }\n\n        // All other inputs\n        default: {\n          assignSimpleDefaultValue()\n          node.removeAttribute('x-model')\n          node.addEventListener('input', (evt) => {\n            const target = evt.target as HTMLInputElement\n            const rawValue = target.value\n            const modifiedValue = modify(rawValue, Reflect.get(ctx.data, value))\n\n            // If modified value is different than raw value, we need to\n            // re-assign this modification back to the original target.\n            if (rawValue !== modifiedValue)\n              target.value = String(modifiedValue)\n\n            Object.assign(ctx.data, { [value]: modifiedValue })\n          })\n\n          ctx.effect(() => (node as HTMLInputElement).value = ctx.eval(value))\n        }\n      }\n      break\n    }\n\n    case 'SELECT': {\n      node = node as HTMLSelectElement\n      assignSimpleDefaultValue()\n\n      node.addEventListener('change', (evt) => {\n        const val = parseValue((evt.target as HTMLSelectElement).value, ctx)\n        Object.assign(ctx.data, { [value]: val })\n      })\n\n      ctx.effect(() => (node as HTMLSelectElement).value = ctx.eval(value))\n      break\n    }\n\n    case 'DETAILS': {\n      node = node as HTMLDetailsElement\n      const defaultOpen = node.attributes.getNamedItem('open')\n      const currentValue = ctx.eval(value)\n\n      node.open = !isNil(currentValue) ? currentValue : (defaultOpen ?? false)\n\n      node.addEventListener('toggle', (evt) => {\n        const isOpen = (evt.target as HTMLDetailsElement).open\n        Object.assign(ctx.data, { [value]: isOpen })\n      })\n\n      ctx.effect(() => (node as HTMLDetailsElement).open = ctx.eval(value))\n      break\n    }\n  }\n}\n","import { isArr, isObj, removeChildren } from '../helpers'\nimport type { ContextAny } from '../context'\nimport { Context } from '../context'\nimport { walk } from '../walker'\nimport type { Directive } from './directives'\n\nexport const processFor: Directive = function (ctx, node, { value, name }) {\n  node.removeAttribute(name)\n  // Remove if from the iterated elements.\n  // Use condition on the child elements instead.\n  node.removeAttribute('x-if')\n\n  /**\n   * Much more limited that vue's synax. No destructuring.\n   * Only supports 3 different types. Array, object and range (number)\n   *\n   * Iteration of objects\n   *  - item in object\n   *  - (value, key, index) in object\n   *\n   * Iteration of arrays\n   *  - item in array\n   *  - (item, index) in array\n   */\n\n  // First, we split strings\n  const [params, _, rawValue] = value.split(/(?!\\(.*)\\s(?![^(]*?\\))/g)\n  const parent = node.parentElement\n\n  /**\n   * REVIEW: maybe in the future\n   *\n   * Evaluation process\n   *\n   * 1. Generate nodes once and save them to an array\n   * 2. On subsequent evaluations, we cache the expression. And iterate on the cached nodes only.\n   *  - If expression changes, we remoe all nodes and go back to step #1\n   *\n   */\n  const originalNode = node.cloneNode(true)\n  node.remove()\n\n  // Methods using this scope's variables\n  // Create new node and context by cloning the original node.\n  const createForItemCtx = () => {\n    const newEl = <HTMLElement>originalNode.cloneNode(true)\n    const newCtx = new Context(newEl, ctx.app)\n    newCtx.extend(ctx)\n    return { newEl, newCtx }\n  }\n\n  // Appends the new element to the parent and walks through attribute setup\n  // itself and its children.\n  const appendAndWalkItem = (newEl: HTMLElement, newCtx: ContextAny) => {\n    parent?.appendChild(newEl)\n    walk(newCtx)\n  }\n\n  ctx.effect(() => {\n    const evalExpr = ctx.eval(rawValue)\n\n    // Before clearing, should remoev ALL children if they exist\n    removeChildren(parent!)\n\n    // Range\n    if (typeof evalExpr === 'number') {\n      for (const i in Array.from({ length: evalExpr })) {\n        const { newEl, newCtx } = createForItemCtx()\n        Object.assign(newCtx.data, { [params]: Number(i) })\n        appendAndWalkItem(newEl, newCtx)\n      }\n    }\n    // Item in array\n    else if (isArr(evalExpr)) {\n      // Extract values from '(value, index?)' string\n      const [valueName, indexName] = params.replace('(', '').replace(')', '').split(',')\n      const trimmedValueName = valueName.trim()\n      const trimmedIndexName = indexName?.trim()\n\n      evalExpr.forEach((item, index) => {\n        const { newEl, newCtx } = createForItemCtx()\n\n        Object.assign(newCtx.data, { [trimmedValueName]: item })\n\n        if (trimmedIndexName)\n          Object.assign(newCtx.data, { [trimmedIndexName]: Number(index) })\n\n        appendAndWalkItem(newEl, newCtx)\n      })\n    }\n    // Iterating in object\n    else if (isObj(evalExpr)) {\n      // Extract values from '(value, key?, index?)' string\n      const [valueName, keyName, indexName] = params.replace('(', '').replace(')', '').split(',')\n      const trimmedValueName = valueName.trim()\n      const trimmedKeyName = keyName?.trim()\n      const trimmedIndexName = indexName?.trim()\n\n      Object.entries(evalExpr).forEach(([key, value], index) => {\n        const { newEl, newCtx } = createForItemCtx()\n\n        Object.assign(newCtx.data, { [trimmedValueName]: value })\n\n        if (trimmedKeyName)\n          Object.assign(newCtx.data, { [trimmedKeyName]: key })\n\n        if (trimmedIndexName)\n          Object.assign(newCtx.data, { [trimmedIndexName]: Number(index) })\n\n        appendAndWalkItem(newEl, newCtx)\n      })\n    }\n\n    else if (import.meta.env.DEV) {\n      throw new TypeError('Unsupported value was used in \\'x-for\\'. Please only use a number, array or an object')\n    }\n  })\n}\n","import { getAttr } from '../helpers'\nimport { applyDirectives } from '../walker'\nimport { processTextNode } from '../text-node'\nimport type { Directive } from './directives'\n\n// REVIEW\n// Should the target have mutation attached observer attached?\n\nexport const processPortal: Directive = function (ctx, original, { name, value }) {\n  // Clone node, teleport clone to the new place, replace current node\n  const clone = original.cloneNode(true) as HTMLElement\n  const target = document.querySelector(value)\n  const [, elPlacement] = name.split(':')\n\n  if (!target) {\n    // Shouldn't throw, as targets can be removed at runtime\n    console.error('No valid target provided for `x-portal`')\n    return\n  }\n\n  // Remove original node and append clone to the target\n  original.remove()\n\n  if (elPlacement === 'prepend')\n    target.prepend(clone)\n  else if (elPlacement === 'replace')\n    target.replaceChildren(clone)\n  else\n    target.append(clone)\n\n  // Walk the new branch. This code is a compressed clone of the\n  // `walk()` function with some differences which aren't necessarily\n  // worth an abstraction\n  const walker = document.createTreeWalker(clone)\n  let node: Node | null = walker.root\n\n  while (node) {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const _node = node as HTMLElement\n\n      if (getAttr(_node, 'x-skip') !== null) {\n        node = walker.nextSibling()\n        continue\n      }\n\n      if (applyDirectives(ctx, _node)) {\n        node = walker.nextSibling()\n        continue\n      }\n    }\n    else if (node.nodeType === Node.TEXT_NODE) {\n      processTextNode(ctx, node)\n    }\n\n    node = walker.nextNode()\n  }\n}\n","import { evaluate } from '../evaluate'\nimport { isObj } from '../helpers'\nimport type { Directive } from './directives'\n\nfunction throwDataErr() {\n  throw new Error('[x-scope/x-data] Error when processing attribute. \\n Most likely an issue with the the data object.')\n}\n\nexport const processData: Directive<boolean> = function (ctx, node, { name, value }) {\n  node.removeAttribute(name)\n\n  if (name === 'x-scope' && ctx.root !== node)\n    throw new Error('Can not initialize a new scope within an existing scope')\n\n  try {\n    if (!value)\n      value = '{ }'\n\n    const data = evaluate({}, value)\n\n    if (!isObj(data))\n      throwDataErr()\n\n    for (const key of Object.keys(data)) {\n      Object.defineProperty(ctx.data, key, {\n        value: data[key],\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  }\n  catch (e) {\n    console.warn('[x-scope/x-data] Error when processing attribute')\n    // console.log(e)\n    throwDataErr()\n  }\n\n  return false\n}\n","import { parseValue } from '../helpers'\nimport { walk } from '../walker'\nimport type { Directive } from './directives'\n\ninterface Block {\n  isDefault: boolean\n  isCase: boolean\n  expr: string | null\n  node: Element\n}\n\nexport const processSwitch: Directive = function (ctx, node, { value }) {\n  node.removeAttribute('x-switch')\n\n  // Since each case/default can be separated by normal non-switch\n  // nodes, we need to replace each with a commenet anchor so we can\n  // re-add it to the DOM in the right place\n  const anchors: Comment[] = []\n\n  // Get all child elements which are part of the switch statement\n  const blocks = Array\n    .from(node.children)\n    // Discard nodes which aren't part of the switch\n    .filter(c => c.hasAttribute('x-case') || c.hasAttribute('x-default'))\n    // Format into a block holding an expression and dom reference\n    .map((el): Block => {\n      return {\n        isDefault: el.hasAttribute('x-default'),\n        isCase: el.hasAttribute('x-case'),\n        expr: el.attributes.getNamedItem('x-case')?.value ?? null,\n        node: el,\n      }\n    })\n    // Remove all nodes from the DOM, they will be reattached based on\n    // the expression\n    .map((block) => {\n      // Insert comment before each node (there can be gaps between cases)\n      const anchor = new Comment('x-switch')\n      node.insertBefore(anchor, block.node)\n      // e.node.insertAdjacentElement('afterend', anchor)\n      anchors.push(anchor)\n      // Remove beskydy attributes and self\n      block.node.removeAttribute('x-case')\n      block.node.removeAttribute('x-default')\n      block.node.remove()\n      return block\n    })\n\n  let currentResult: Block | null\n\n  function clear() {\n    if (currentResult) {\n      currentResult.node.remove()\n      currentResult = null\n    }\n  }\n\n  ctx.effect(() => {\n    const result = ctx.eval(value)\n    let res: [Block, number] | undefined\n\n    for (let i = 0; i < blocks.length; i++) {\n      const block = blocks[i]\n\n      // If default is NOT last, we save it in case the following expression are not the result\n      if (i < blocks.length - 1 && block.isDefault)\n        res = [block, i]\n\n      if (block.expr) {\n        const blockResult = parseValue(block.expr, ctx)\n\n        if (blockResult === result) {\n          res = [block, i]\n          break\n        }\n      }\n      else if (i === blocks.length - 1) {\n        // We can expect we hit a `x-case` if we are on the last index and\n        // block is missing expression\n        res = [block, i]\n      }\n    }\n\n    if (res) {\n      clear()\n      const [block, index] = res\n      const anchor = anchors[index]\n      node.insertBefore(block.node, anchor)\n      walk(ctx, block.node)\n      currentResult = block\n      return\n    }\n\n    clear()\n  })\n}\n","import type { ContextAny } from '../context'\nimport type { Directive } from './directives'\n\n/**\n * Runs provided callback each time the context dataset is updated\n */\nexport const processSpy: Directive = function (ctx, node, { name, value }) {\n  // Check wether we are spyng on specific keys in the context dataset\n  const [_, ...spyOnParams] = name.split(':')\n\n  // let firstFired = false\n\n  // Store previously saved dataset to compare values when we're spying on specific properties\n  let previousData: ContextAny['data'] = Object.create(null)\n\n  ctx.effect(() => {\n    // Ignore first fire as that's when the scope is registered\n    // if (!firstFired) {\n    //   firstFired = true\n    //   return\n    // }\n\n    if (spyOnParams.length > 0) {\n      for (const key of spyOnParams) {\n        if (Reflect.get(previousData, key) !== Reflect.get(ctx.data, key)) {\n          ctx.eval(value, node)\n          break\n        }\n      }\n\n      previousData = { ...ctx.data }\n    }\n    else {\n      ctx.eval(value, node)\n    }\n  })\n}\n","import type { Directive } from '..'\n\n// Simply runs the provided expression\n// This is used for lifecycle methods\n// `x-init` = runs when all data is registered\n// `x-mount` = runs when all other directives have been processed\nexport const processLifecycle: Directive = (ctx, node, attr) => {\n  node.removeAttribute(attr.name)\n  ctx.eval(attr.value, node)\n}\n","import { getAttr, getElementIndex } from './helpers'\nimport type { ContextAny } from './context'\nimport { processRef } from './directives/x-ref'\nimport { processText } from './directives/x-text'\nimport { processStyle } from './directives/x-style'\nimport { processShow } from './directives/x-show'\nimport { processHTML } from './directives/x-html'\nimport { processBind } from './directives/x-bind'\nimport { processClass } from './directives/x-class'\nimport { processOn } from './directives/x-on'\nimport { processIf } from './directives/x-if'\nimport { processModel } from './directives/x-model'\nimport { processFor } from './directives/x-for'\nimport { processPortal } from './directives/x-portal'\nimport { processTextNode } from './text-node'\nimport { processData } from './directives/x-data'\nimport { processSwitch } from './directives/x-switch'\nimport { processSpy } from './directives/x-spy'\nimport { processLifecycle } from './directives/x-lifecycle'\n\nexport async function walk(ctx: ContextAny, forcedRoot?: Element) {\n  const rootEl = forcedRoot ?? ctx.root\n  let walker = document.createTreeWalker(rootEl)\n  let node: Node | null = walker.root\n\n  // Before we process directives, we first iterate over any data\n  // defining elements This will make sure that all the data objects are\n  // available to all elements within a scope/ That means we can\n  // reference a variable before it is defined.\n\n  // This approach might be against javascript conventions, but it is\n  // important to remember that the nesting of elements should not\n  // matter when usiny Beskydy. Each x-scope and all its descendants\n  // should be treated as a single, flat \"scope\".\n\n  const rootDatasets = (rootEl).querySelectorAll('[x-data]')\n  const rootScopeAttr = (rootEl).getAttributeNode('x-scope')\n\n  if (rootScopeAttr)\n    processData(ctx, rootEl, rootScopeAttr)\n\n  for (const rootDataset of rootDatasets) {\n    // We can ignore the fact that getAttributeNode can return null, as\n    // all the iterated elements have explicitly been queried by the\n    // `x-data` attribute\n    processData(ctx, rootDataset, rootDataset.getAttributeNode('x-data')!)\n  }\n\n  /// /////////////////////\n\n  while (node) {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE: {\n        // Element\n        const _node = node as HTMLElement\n\n        // SECTION x-skip\n        // Elements with x-skip will be skipped during evaluation. The\n        // skip includes all elements children. Selects the next sibling.\n        if (getAttr(_node, 'x-skip') !== null) {\n          node = walker.nextSibling()\n          continue\n        }\n\n        // SECTION x-portal\n        // A section of DOM disconnected from the context\n        // tree but still within the reactive scope. We essentially need\n        // to create another walker within this walker to temporarily\n        // traverse the detached dom tree\n        let portalAttr\n        if (portalAttr = Array.from(_node.attributes).find(a => a.name.startsWith('x-portal')))\n          processPortal(ctx, _node, portalAttr)\n\n        // If appliy directives returns true, we want to skip to the next\n        // sibling instead of going deeper. This requires creating a new walker\n        // because the DOM has changed after using x-if/x-for.\n\n        // Save node index\n        const nodeIndex = getElementIndex(node)\n\n        if (applyDirectives(ctx, _node)) {\n          const tempWalker = document.createTreeWalker(rootEl)\n          let tempNode: Node | null = tempWalker.root\n          // Iterate until we are left off where the last walker ended (on the index)\n          let i = 0\n          while (tempNode && i !== nodeIndex) {\n            tempNode = tempWalker.nextNode()\n            i++\n          }\n\n          walker = tempWalker\n          node = tempWalker.currentNode\n\n          continue\n        }\n\n        break\n      }\n\n      case Node.TEXT_NODE: {\n        // SECTION Text Node\n        // 1. Save string\n        // 2. Extract expression\n        // 3. Replace entire content between delimiters with the result of the expression\n        processTextNode(ctx, node)\n        break\n      }\n    }\n\n    node = walker.nextNode()\n  }\n}\n\n// Can be re-run on sub-sequent dom changes\nexport function applyDirectives(ctx: ContextAny, node: HTMLElement): boolean | void {\n  for (const attr of Array.from(node.attributes)) {\n    // REVIEW\n    // Unsure if the order of attribute processing is correct,\n    // but so far it hasn't posed any issues. Just adding this here so\n    // later we do a real review\n\n    // When scope has had its data registered, we can execute the init hook\n    if (attr.name === 'x-init') {\n      processLifecycle(ctx, node, attr)\n      continue\n    }\n\n    // In case if and for are on the same element, the if is removed.\n    if (attr.name === 'x-for') {\n      processFor(ctx, node, attr)\n\n      return true\n    }\n    else if (attr.name === 'x-if') {\n      const shouldSkipNode = processIf(ctx, node, attr)\n\n      // This looks wonky, but we only want to return a value if the\n      // sibling should be skipped. If not, we want this function to\n      // continue further.\n      if (shouldSkipNode) {\n        // REVIEW: ive no fucking clue man\n        return true\n      }\n\n      continue\n    }\n\n    if (attr.name === 'x-switch') {\n      processSwitch(ctx, node, attr)\n      continue\n    }\n\n    if (attr.name === 'x-ref') {\n      processRef(ctx, node, attr)\n      continue\n    }\n\n    if (attr.name.startsWith('x-model')) {\n      processModel(ctx, node, attr)\n      continue\n    }\n\n    if (attr.name.startsWith('x-bind') || attr.name.startsWith(':')) {\n      processBind(ctx, node, attr)\n      continue\n    }\n\n    if (attr.name.startsWith('@') || attr.name.startsWith('x-on')) {\n      processOn(ctx, node, attr)\n      continue\n    }\n\n    if (attr.name.startsWith('x-spy')) {\n      processSpy(ctx, node, attr)\n      continue\n    }\n\n    if (attr.name === 'x-text') {\n      processText(ctx, node, attr)\n      continue\n    }\n\n    if (attr.name === 'x-class') {\n      processClass(ctx, node, attr)\n      continue\n    }\n\n    if (attr.name === 'x-html') {\n      processHTML(ctx, node, attr)\n      continue\n    }\n\n    if (attr.name === 'x-style') {\n      processStyle(ctx, node, attr)\n      continue\n    }\n\n    if (attr.name === 'x-show') {\n      processShow(ctx, node, attr)\n      continue\n    }\n\n    // Custom directive implementation\n    const keys = Object.keys(ctx.app.customDirectives)\n\n    if (keys.length > 0) {\n      for (const key of keys) {\n        const directive = ctx.app.customDirectives[key]\n        if (attr.name.startsWith(key))\n          directive(ctx, node, attr)\n      }\n    }\n\n    // When scope has had its data registered, we can execute the init hook\n    if (attr.name === 'x-processed') {\n      processLifecycle(ctx, node, attr)\n      continue\n    }\n  }\n}\n","import type { UnwrapNestedRefs } from '@vue/reactivity'\nimport { reactive } from '@vue/reactivity'\nimport type { ContextAny } from './context'\nimport { Context } from './context'\nimport type { Directive, EventModifierFn } from './directives/directives'\nimport { walk } from './walker'\nimport { eventModifiers } from './directives/x-on'\nimport type { ModelModifierFn } from './directives/x-model'\nimport { modelModifiers } from './directives/x-model'\n\n// Custom modifiers warning message, which is shared across all three of them\nconst warnEnd = 'is a reserved name or its already been defined. Please use a different name.'\ntype Cb = () => void\n\nfunction escapeRegex(str: string) {\n  return str.replace(/[-.*+?^${}()|[\\]\\/\\\\]/g, '\\\\$&')\n}\n\nfunction createDelimiterRegex(start: string, end: string) {\n  return new RegExp(\n    `${escapeRegex(start)}([^]+?)${escapeRegex(end)}`,\n    'g',\n  )\n}\n\nexport class Beskydy<T extends object> {\n  modelModifiers: Record<string, ModelModifierFn>\n  eventModifiers: Record<string, EventModifierFn>\n  customDirectives: Record<string, Directive>\n  delimiters: {\n    start: string\n    end: string\n    re: RegExp\n  }\n\n  private scopes: ContextAny[]\n  rootState: UnwrapNestedRefs<T>\n  private onInitCbs: Cb[]\n  private onTeardownCbs: Cb[]\n\n  constructor(initialDataset?: T) {\n    this.modelModifiers = Object.assign({}, modelModifiers)\n    this.eventModifiers = Object.assign({}, eventModifiers)\n    this.customDirectives = {}\n    this.delimiters = {\n      start: '{{',\n      end: '}}',\n      re: createDelimiterRegex('{{', '}}'),\n    }\n    this.scopes = []\n    this.rootState = reactive(Object.assign({}, initialDataset))\n    this.onInitCbs = []\n    this.onTeardownCbs = []\n  }\n\n  /**\n   * Define the way Beskydy will compile the delimiters {{ }} into a reactive part of a string.\n   * Delimiters contain text, which usually contains an expression. Think of it was as javascript being executed within a string when it is wrapped in the delimiters {{ }}\n   *\n   *\n   * @param start Starting delimiter\n   * @param end Ending delimiter\n   */\n  setDelimiters(start: string, end: string) {\n    if (start === '{' || end === '}')\n      console.warn('You are using {} as delimiters, please keep in mind that you will not be able to use template literals inside of them.')\n    this.delimiters = { start, end, re: createDelimiterRegex(start, end) }\n  }\n\n  /**\n   * Add a custom directive (element attribute)\n   *\n   * @param name Directive name, preferably should start with `x-`\n   * @param fn Directive implementation\n   */\n  defineDirective(name: string, fn: Directive) {\n    if (name in this.customDirectives)\n      throw new Error(`The directive \"${name}\" ${warnEnd}`)\n    this.customDirectives[name] = fn\n  }\n\n  /**\n   * Add a custom `x-on` event modifier\n   *\n   * @param name Modifier name\n   * @param fn Modifier implementation\n   */\n  defineEventModifier(name: string, fn: EventModifierFn) {\n    if (name in this.eventModifiers)\n      throw new Error(`The event modifier \"${name}\" ${warnEnd}`)\n    this.eventModifiers[name] = fn\n  }\n\n  /**\n   * Add a custom `x-model` modifier\n   *\n   * @param name Modifier name\n   * @param fn Modifier implementation\n   */\n  defineModelModifier(name: string, fn: ModelModifierFn) {\n    if (name in this.modelModifiers)\n      throw new Error(`The model modifier \"${name}\" ${warnEnd}`)\n    this.modelModifiers[name] = fn\n  }\n\n  /**\n   *  Initialize Beskydy. It starts by collecting all the scope elements\n   *  and creating a context for each.\n   *\n   * @param selector Custom attribute selector. Defaults to 'x-scope'\n   */\n  collect(selector: string = '[x-scope]') {\n    const scopeRoots = Array.from(document.querySelectorAll(selector))\n    if (scopeRoots.length === 0)\n      console.warn(`No scopes were found for the selector \"${selector}\". Make sure to define at least one.`)\n\n    for (const scopeRoot of scopeRoots) {\n      const ctx = new Context(scopeRoot, this, {})\n      // Hide scope until it's initialized\n      scopeRoot.setAttribute('style', 'display:none;')\n      walk(ctx)\n      ctx.init = true\n      scopeRoot.removeAttribute('style')\n      this.scopes.push(ctx)\n    }\n\n    for (const cb of this.onInitCbs)\n      cb()\n  }\n\n  /**\n   * Registers a function which runs when app is fully initialized\n   */\n  onInit(fn: Cb) {\n    this.onInitCbs.push(fn)\n  }\n\n  /**\n   * Registers a callback which runs after application has been shut down\n   */\n  onTeardown(fn: Cb) {\n    this.onTeardownCbs.push(fn)\n  }\n\n  /**\n   *   Stops Beskydy instance, removes reactivity and event listeners\n   *   and leaves the DOM in the state it was when the app was torn down.\n   */\n  teardown() {\n    for (const ctx of this.scopes)\n      ctx.teardown()\n\n    this.scopes.length = 0\n\n    // REVIEW\n    // Should the onTeardown callbacks run before teardown or right after?\n    for (const cb of this.onTeardownCbs)\n      cb()\n  }\n}\n","import { Beskydy } from './beskydy'\nimport type { Directive, EventModifierFn, Primitive } from './directives/directives'\nimport type { ModelModifierFn } from './directives/x-model'\n\nexport {\n  Beskydy,\n  Directive,\n  Primitive,\n  EventModifierFn,\n  ModelModifierFn,\n}\n\n//////////////////////////////////////////////\n\nconst app = new Beskydy({\n  selected: 'people',\n  loading: false,\n  data: [],\n  fetchData() {\n    this.loading = true\n    fetch(`https://swapi.dev/api/${this.selected}`)\n      .then(r => r.json())\n      .then((r) => {\n        this.data = r.results\n      })\n      .finally(() => {\n        this.loading = false\n      })\n  },\n  // makeElement() {\n  //   return document.createElement(\"table\")\n  // }\n})\n\n// app.defineDirective('x-three', (ctx, el, attr) => {\n//   ctx.effect(() => {\n//     const value: number = ctx.eval(attr.value)\n\n//     if (value % 3 === 0) {\n//       el.textContent = \"DIVISIBLE BY THREE!!!\"\n//     } else {\n//       el.textContent = String(value)\n//     }\n//   })\n// })\n\n// Modify the model value\n// app.defineModelModifier('maxlength', (value, prevValue, length: number) => {\n//   if (value.length > length)\n//     return prevValue\n//   return value\n// })\n\n// // Modify if event is registered\n// app.defineEventModifier('every', (_, state, param) => {\n//   return state.calledTimes % Number(param) === 0\n// })\n\napp.collect()\n"],"names":["evalCache","evaluate","scope","exp","el","execute","event","fn","toFunction","e","Context","root","app","initialDataset","__publicField","reactive","handler","rawEffect","key","ref","ctx","expr","clone","_a","getAttr","attr","isNil","value","isObj","isArr","removeChildren","node","parseValue","getElementIndex","child","i","processRef","name","toDisplayString","processTextNode","delimiters","originalTextContent","segments","lastIndex","match","leading","processText","processStyle","result","processShow","processHTML","processBind","_","propertyName","setOrDelAttr","results","processClass","assignObjectClasses","parsed","prevInlineResults","prevResult","previous","eventModifiers","lastCall","amount","__","rawEval","calledTimes","callLimit","processOn","eventKeyRaw","eventKey","modifiers","modifier","rawParams","param","parsedModifier","state","processIf","parent","anchor","blocks","elseEl","elseExpr","currentIndex","currentResult","clear","shouldGoNextSibling","index","block","walk","modelModifiers","prevValue","processModel","defaultValue","modify","newValue","oldValue","assignSimpleDefaultValue","finalValue","modelValue","setCheckboxValue","checked","evt","target","rawValue","modifiedValue","val","defaultOpen","currentValue","isOpen","processFor","params","originalNode","createForItemCtx","newEl","newCtx","appendAndWalkItem","evalExpr","valueName","indexName","trimmedValueName","trimmedIndexName","item","keyName","trimmedKeyName","processPortal","original","elPlacement","walker","_node","applyDirectives","throwDataErr","processData","data","processSwitch","anchors","c","res","processSpy","spyOnParams","previousData","processLifecycle","forcedRoot","rootEl","rootDatasets","rootScopeAttr","rootDataset","portalAttr","a","nodeIndex","tempWalker","tempNode","keys","directive","warnEnd","escapeRegex","str","createDelimiterRegex","start","end","Beskydy","selector","scopeRoots","scopeRoot","cb","r"],"mappings":"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"}