{"version":3,"file":"beskydy.js","sources":["../src/evaluate.ts","../src/context.ts","../src/helpers.ts","../src/directives/x-ref.ts","../src/directives/x-text.ts","../src/directives/x-style.ts","../src/directives/x-show.ts","../src/directives/x-html.ts","../src/directives/x-bind.ts","../src/directives/x-class.ts","../src/directives/x-on.ts","../src/directives/x-if.ts","../src/directives/x-model.ts","../src/directives/x-for.ts","../src/text-node.ts","../src/directives/x-portal.ts","../src/directives/x-data.ts","../src/directives/x-switch.ts","../src/directives/x-spy.ts","../src/directives/x-lifecycle.ts","../src/walker.ts","../src/beskydy.ts","../src/index.ts"],"sourcesContent":["/**\r\n * Thank you so much Evan You, I love you\r\n */\r\n\r\nconst evalCache: Record<string, Function> = Object.create(null)\r\n\r\nexport function evaluate(scope: any, exp: string, el?: Node) {\r\n  return execute(scope, `return(${exp})`, el)\r\n}\r\n\r\nexport function execute(scope: any, exp: string, el?: Node, event?: Event) {\r\n  // By calling stringify, the function hits every single property within an\r\n  // object. No matter how deep it is. This way we can ensure deep reactivity\r\n  // Thanks to Alpine.js core for the tip\r\n  JSON.stringify(scope)\r\n\r\n  const fn = evalCache[exp] || (evalCache[exp] = toFunction(exp))\r\n  try {\r\n    return fn(scope, el, event)\r\n  }\r\n  catch (e) {\r\n    if (import.meta.env.DEV) {\r\n      // console.log(scope)\r\n      console.warn(`Error when evaluating expression \"${exp}\":`)\r\n    }\r\n    console.error(e)\r\n  }\r\n}\r\n\r\nfunction toFunction(exp: string): Function {\r\n  try {\r\n    // eslint-disable-next-line no-new-func\r\n    return new Function('data', '$el', '$event', `with(data){${exp}}`)\r\n  }\r\n  catch (e) {\r\n    console.error(`${(e as Error).message} in expression: ${exp}`)\r\n    return () => { }\r\n  }\r\n}\r\n","import type { ReactiveEffectRunner, UnwrapNestedRefs } from '@vue/reactivity'\r\nimport { effect as rawEffect, reactive } from '@vue/reactivity'\r\nimport type { Beskydy } from './beskydy'\r\nimport { evaluate } from './evaluate'\r\n\r\nexport type ContextAny = Context<Element, Beskydy<object>, object>\r\n\r\n// Piece of DOM which holds its own state. This class can be used on its\r\n// own, but requires an instance of Beskydy to provide modifiers to a\r\n// few directives.\r\n\r\n// In case you want to create custom context, you can just do:\r\n// const ctx = new Context(root, new Beskydy())\r\n\r\nexport class Context<R extends Element, A extends Beskydy<object>, T extends object> {\r\n  // Store the context's root element\r\n  root: Element\r\n  // Reactive dataset available to the entire scope\r\n  data: UnwrapNestedRefs<T & { $refs: Record<string, Element> }>\r\n  init: boolean\r\n  // Hold all context runners for disposal\r\n  effects: ReactiveEffectRunner[] = []\r\n\r\n  // Stores a referene to the root app instance\r\n  app: Beskydy<object>\r\n\r\n  constructor(root: R, app: A, initialDataset?: T) {\r\n    this.root = root\r\n    this.data = reactive(Object.assign({ $refs: {} }, app.rootState, initialDataset))\r\n    this.init = false\r\n    this.app = app\r\n  }\r\n\r\n  /**\r\n   * Executes the provided callback fn whenever the context's reactive\r\n   * dataset updates\r\n   *\r\n   * @param fn Callback\r\n   */\r\n  effect(fn: () => any) {\r\n    const handler = rawEffect(fn)\r\n    this.effects.push(handler)\r\n  }\r\n\r\n  /**\r\n   * Stores a reference to a DOM element by the provided key. This\r\n   * allows us to use $refs object within expressions\r\n   *\r\n   * @param key Ref key\r\n   * @param ref Element\r\n   */\r\n  addRef(key: string, ref: Element) {\r\n    Object.assign(this.data.$refs, { [key]: ref })\r\n  }\r\n\r\n  /**\r\n   * When creating sub contexts, this allows for a parent context to\r\n   * share its reactive properties with the child context\r\n   *\r\n   * @param ctx Context\r\n   */\r\n  extend(ctx: ContextAny) {\r\n    Object.assign(this.data, ctx.data)\r\n  }\r\n\r\n  /**\r\n   * Evaluates the provided expression against the context dataset\r\n   *\r\n   * @param expr Expression\r\n   * @param el Optionally, make the current element available as $el\r\n   * @returns Evaluated value\r\n   */\r\n  eval(expr: string, el?: Node | undefined) {\r\n    return evaluate(this.data, expr, el)\r\n  }\r\n\r\n  /**\r\n   * Turns the scope's elements to the original static HTML. Removes\r\n   * event listeners and stops reactive watchers.\r\n   */\r\n  teardown() {\r\n    // Iterate over all children of a ctx and remove any beskydy functionality\r\n    this.effects.forEach(e => e.effect.stop())\r\n    this.effects.length = 0\r\n\r\n    // Clone whole subtree and re-attach it to the parent. This removes any event listeners\r\n    const clone = this.root.cloneNode(true)\r\n    this.root.parentElement?.replaceChild(clone, this.root)\r\n\r\n    // Overwrite context dataset with an empty object\r\n    Reflect.set(this, 'data', Object.create(null))\r\n\r\n    this.init = false\r\n  }\r\n}\r\n","import type { Primitive } from './directives/directives'\r\nimport type { ContextAny } from './context'\r\nimport { evaluate } from './evaluate'\r\n\r\nexport function isSibling(el: HTMLElement, el2: HTMLElement) {\r\n  return el !== el2 && el.parentNode === el2.parentNode\r\n}\r\n\r\nexport function getAttr(el: HTMLElement | Element, key: string) {\r\n  const attr = el.attributes.getNamedItem(key)\r\n  if (!attr)\r\n    return null\r\n  el.removeAttribute(key)\r\n  return attr.value ?? true\r\n}\r\n\r\nexport function isNil(value: unknown) {\r\n  return value === undefined || value === null\r\n}\r\n\r\nexport function isObj(value: unknown) {\r\n  return (!!value) && (value.constructor === Object)\r\n}\r\n\r\nexport const isArr = Array.isArray\r\n\r\nexport const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport function removeChildren(node: Element) {\r\n  while (node.lastElementChild)\r\n    node.removeChild(node.lastElementChild)\r\n}\r\n\r\nexport function isType(val: any, requiredType: Primitive) {\r\n  // eslint-disable-next-line valid-typeof\r\n  return typeof val === requiredType\r\n}\r\n\r\nexport function parseValue(value: string, ctx: ContextAny): Primitive {\r\n  if (value in ctx.data) {\r\n    return evaluate(ctx.data, value)\r\n  }\r\n  else {\r\n    if (value === 'undefined')\r\n      return undefined\r\n    else if (value === 'null')\r\n      return null\r\n    else if (value === 'true' || value === 'false')\r\n      return Boolean(value)\r\n    // eslint-disable-next-line unicorn/prefer-number-properties\r\n    else if (!isNaN(value as any))\r\n      return Number(value)\r\n    else\r\n      return value\r\n  }\r\n}\r\n\r\nexport function parseDelimiter(delimiter: string) {\r\n  return [...delimiter].reduce((group, item) => {\r\n    return group += `\\\\${item}`\r\n  }, '')\r\n}\r\n","import type { Directive } from './directives'\r\n\r\nexport const processRef: Directive = function (ctx, node, { value, name }) {\r\n  node.removeAttribute(name)\r\n  // Add ref once\r\n  ctx.addRef(value, node)\r\n\r\n  // Update whenever ref's items are changed\r\n  const mo = new MutationObserver(() => {\r\n    ctx.addRef(value, node)\r\n  })\r\n\r\n  mo.observe(node, {\r\n    attributes: true,\r\n    childList: true,\r\n    subtree: true,\r\n    characterData: true,\r\n  })\r\n}\r\n","import type { Directive } from './directives'\r\n\r\nexport const processText: Directive = function (ctx, node, { name, value }) {\r\n  node.removeAttribute(name)\r\n  const expr = value\r\n  ctx.effect(() => {\r\n    node.textContent = ctx.eval(expr, node)\r\n  })\r\n}\r\n","import { isObj } from '../helpers'\r\nimport type { Directive } from './directives'\r\n\r\nexport const processStyle: Directive = function (ctx, node, { value, name }) {\r\n  node.removeAttribute(name)\r\n\r\n  const expr = value\r\n\r\n  ctx.effect(() => {\r\n    const result = ctx.eval(expr, node)\r\n\r\n    if (!isObj(result))\r\n      return\r\n\r\n    for (const key of Object.keys(result)) {\r\n      // If it's a non HTMLElement node, skip it\r\n      if (!Reflect.has(node, 'style'))\r\n        continue\r\n\r\n      // Using reflect set allows us using camelCase and kebab-case styles\r\n      Reflect.set((node as HTMLElement).style, key, result[key])\r\n    }\r\n  })\r\n}\r\n","import type { Directive } from './directives'\r\n\r\n/**\r\n * Takes in and evaluates an expression. Based on the result the element\r\n * is either shown or hidden in the DOM.\r\n */\r\nexport const processShow: Directive = function (ctx, node, { value, name }) {\r\n  node.removeAttribute(name)\r\n\r\n  const expr = value\r\n\r\n  if (!Reflect.has(node, 'style'))\r\n    return\r\n\r\n  ctx.effect(() => {\r\n    const result = ctx.eval(expr, node)\r\n    if (result)\r\n      (node as HTMLElement).style.removeProperty('display')\r\n    else\r\n      (node as HTMLElement).style.setProperty('display', 'none')\r\n  })\r\n}\r\n","import type { Directive } from './directives'\r\n\r\nexport const processHTML: Directive = function (ctx, node, { value, name }) {\r\n  node.removeAttribute(name)\r\n  const expr = value\r\n  ctx.effect(() => {\r\n    const result = ctx.eval(expr, node)\r\n\r\n    if (result instanceof Element) {\r\n      node.replaceChildren()\r\n      node.append(result)\r\n    }\n    else {\r\n      node.innerHTML = result\r\n    }\r\n  })\r\n}\r\n","import { isNil } from '../helpers'\r\nimport type { Directive } from './directives'\r\n\r\n/**\r\n * Dynamically bind attribute or attributes if the expression passes\r\n *\r\n * Allowed syntax\r\n *\r\n * This syntax will bind a value-less attribute (boolean attribute) if the expression matches\r\n * - :attributeName=\"expression\"\r\n * - x-bind:attributeName=\"expression\"\r\n * - x-bind=\"{ attributeValue: expression }\"\r\n */\r\nexport const processBind: Directive = function (ctx, node, { name, value }) {\r\n  node.removeAttribute(name)\r\n\r\n  const [_, propertyName] = name.split(':')\r\n\r\n  const setOrDelAttr = (key: string, value: any) => {\r\n    // If no value is provided or the value is a boolean, remove the\r\n    // attribute instead of simply setting it to the value.\r\n\r\n    // The reason for that is disabled=\"false\" will still disable the\r\n    // attribute, as boolean attributes dont care about the value\r\n    if (isNil(value) || value === false)\r\n      node.removeAttribute(key)\r\n    else\r\n      node.setAttribute(key, value)\r\n  }\r\n\r\n  if (propertyName) {\r\n    // x-bind:propertyName=\"\" syntax\r\n    ctx.effect(() => {\r\n      const result = ctx.eval(value, node)\r\n      setOrDelAttr(propertyName, result)\r\n    })\r\n  }\r\n  else {\r\n    // x-bind=\"{}\" syntax\r\n    ctx.effect(() => {\r\n      const results = ctx.eval(value, node) ?? {}\r\n\r\n      for (const key of Object.keys(results)) {\r\n        const result = results[key]\r\n        setOrDelAttr(key, result)\r\n      }\r\n    })\r\n  }\r\n}\r\n","import { isObj } from '../helpers'\r\nimport type { Directive } from './directives'\r\n\r\nexport const processClass: Directive = function (ctx, node, { value }) {\r\n  const assignObjectClasses = (parsed: Record<string, unknown>) => {\r\n    for (const key of Object.keys(parsed)) {\r\n      if (parsed[key])\r\n        node.classList.add(key)\r\n      else\r\n        node.classList.remove(key)\r\n    }\r\n  }\r\n\r\n  if (value.startsWith('[')) {\r\n    // Evaluate Should receive an array of strings or objects. Iterate on it and\r\n    // call either of the process functions\r\n    const prevInlineResults: Record<number, string | null> = Object.create(null)\r\n\r\n    ctx.effect(() => {\r\n      const results = ctx.eval(value)\r\n\r\n      for (let i = 0; i < results.length; i++) {\r\n        const result = results[i]\r\n\r\n        if (!result) {\r\n          const prevResult = prevInlineResults[i]\r\n\r\n          if (prevResult) {\r\n            node.classList.remove(prevResult)\r\n            prevInlineResults[i] = null\r\n          }\r\n        }\r\n        else if (typeof result === 'string') {\r\n          node.classList.add(result)\r\n          prevInlineResults[i] = result\r\n        }\r\n        else if (isObj(result)) {\r\n          assignObjectClasses(result)\r\n        }\r\n      }\r\n    })\r\n  }\r\n  else if (value.startsWith('{') && value.endsWith('}')) {\r\n    // Processes object expression. If the value is truthy, the key will be\r\n    // assigned as a classname\r\n    // Eg: { className: expression, display: isVisible }\r\n    ctx.effect(() => {\r\n      const parsed: Record<string, unknown> = ctx.eval(value, node)\r\n      assignObjectClasses(parsed)\r\n    })\r\n  }\r\n  else {\r\n    // Processes inline ternary operator expression\r\n    // Eg: \"value ? 'class' : null\"\r\n    let previous: string\r\n    ctx.effect(() => {\r\n      if (previous)\r\n        node.classList.remove(previous)\r\n\r\n      previous = ctx.eval(value, node)\r\n      node.classList.add(previous)\r\n    })\r\n  }\r\n}\r\n","import { execute } from '../evaluate'\r\nimport { parseValue } from '../helpers'\r\nimport type { Directive, EventModifierFn, Modifier, ModifierListenerState, Primitive } from './directives'\r\n\r\n// Default event modifiers which are bound to an app instance\r\nexport const eventModifiers: Record<string, EventModifierFn> = {\r\n  throttle: (_, { lastCall }, amount = 300) => {\r\n    if (typeof amount !== 'number')\r\n      return false\r\n    if (Date.now() - lastCall >= amount)\r\n      return true\r\n    return false\r\n  },\r\n  if: (_, __, rawEval) => !!rawEval,\r\n  only: (_, { calledTimes }, callLimit = 1) => {\r\n    if (typeof callLimit !== 'number')\r\n      return false\r\n    return calledTimes < callLimit\r\n  },\r\n  once: (_, { calledTimes }) => calledTimes < 1,\r\n  self: e => e.target === e.currentTarget,\r\n  left: e => 'button' in e && (e as MouseEvent).button === 0,\r\n  middle: e => 'button' in e && (e as MouseEvent).button === 1,\r\n  right: e => 'button' in e && (e as MouseEvent).button === 2,\r\n  prevent: (e) => {\r\n    e.preventDefault()\r\n    return true\r\n  },\r\n  stop: (e) => {\r\n    e.stopPropagation()\r\n    return true\r\n  },\r\n  stopImmediate: (e) => {\r\n    e.stopImmediatePropagation()\r\n    return true\r\n  },\r\n}\r\n\r\n/**\r\n * Binds an event listener with optional modifiers to the selected\r\n * element. The provided expression is evaluated whenever the event is\r\n * fired.\r\n */\r\nexport const processOn: Directive = function (ctx, node, { name, value }) {\r\n  node.removeAttribute(name)\r\n\r\n  // Get the event name and its modifiers. The two supported syntaxes\r\n  // for binding event listeners are using either `@event` or\r\n  // `x-on:event`. With optional modifiers appended by using\r\n  // `@event.modifier.modifier` etc\r\n  const eventKeyRaw = (name.startsWith('x-on') ? name.split(':')[1] : name.substring(1)).split('.')\r\n  const eventKey = eventKeyRaw[0]\r\n\r\n  // Collect optional modifiers from the event name\r\n  // (event.modifier.modifier) and filter out ones which aren't\r\n  // supported (aka user errors)\r\n  const modifiers: Modifier[] = eventKeyRaw\r\n    .slice(1)\r\n    .map((modifier) => {\r\n      // Split modifier into a key and possible parameter\r\n      // eventKey[param]=\"\"\r\n      const [key, rawParams] = modifier.split('[')\r\n      let param: Primitive\r\n\r\n      if (rawParams) {\r\n        const parsedModifier = rawParams.replace(']', '')\r\n        // The parameter can be a reactive variable.\r\n        // So we should evaluate it against the current context, but only if its available\r\n        param = parseValue(parsedModifier, ctx)\r\n      }\r\n\r\n      return { key, param }\r\n    })\r\n    .filter((modifier) => {\r\n      return Object.keys(ctx.app.eventModifiers).includes(modifier.key)\r\n    })\r\n\r\n  if (value.startsWith('('))\r\n    value = `(${value})()`\r\n\r\n  // State variables, which some of the modifiers use\r\n  const state: ModifierListenerState = {\r\n    calledTimes: 0,\r\n    lastCall: 0,\r\n  }\r\n\r\n  node.addEventListener(eventKey, (event: Event) => {\r\n    // Only execute callback if every modifier passes\r\n    if (modifiers.every(modifier => ctx.app.eventModifiers[modifier.key](event, state, modifier.param)))\r\n      execute(ctx.data, value, node, event)\r\n\r\n    state.calledTimes++\r\n    state.lastCall = Date.now()\r\n  })\r\n}\r\n","import { getAttr } from '../helpers'\r\nimport { walk } from '../walker'\r\nimport type { Directive } from './directives'\r\n\r\ninterface Block {\r\n  expr: string | null\r\n  node: HTMLElement\r\n}\r\n\r\n/**\r\n * Takes in an expression and based on its result, the elements are\r\n * either completely removed or (re)added to the DOM.\r\n *\r\n * The usage syntax and rules\r\n *  x-if        // Requires expression\r\n *  x-else-if   // Requires expression and adjacent x-if or x-if-else\r\n *  x-else      // Requires adjacent x-if or x-else\r\n */\r\n\r\nexport const processIf: Directive<boolean> = function (ctx, node, { name, value }) {\r\n  node.removeAttribute(name)\r\n\r\n  // Holds the reference to the element and its parent node\r\n  const parent = node.parentElement!\r\n\r\n  // This serves as an \"anchor\" to mount the element back in if the provided expression returns true\r\n  const anchor = new Comment('x-if')\r\n  parent.insertBefore(anchor, node)\r\n\r\n  // Store each element as a block with its expression\r\n  const blocks: Block[] = [{\r\n    node: node as HTMLElement,\r\n    expr: value,\r\n  }]\r\n\r\n  // Look for v-else-if and v-else elements and their expression\r\n  let elseEl: Element | null\r\n  let elseExpr: string | null\r\n  while ((elseEl = node.nextElementSibling) !== null) {\r\n    if ((elseExpr = getAttr(elseEl, 'x-else')) !== null || (elseExpr = getAttr(elseEl, 'x-else-if'))) {\r\n      blocks.push({\r\n        node: elseEl as HTMLElement,\r\n        expr: elseExpr,\r\n      })\r\n\r\n      // Remove them because they can be re-added during evaluation process\r\n      parent.removeChild(elseEl)\r\n    }\r\n    else {\r\n      // If the NEXT sibling does not contain one of these,\r\n      // stop checking. As only adjacent elements to the first\r\n      // x-if can be tied to it. Gaps aren't allowed\r\n      break\r\n    }\r\n  }\r\n\r\n  parent.removeChild(node)\r\n\r\n  let currentIndex: number\r\n  let currentResult: Block | null\r\n\r\n  function clear() {\r\n    if (currentResult) {\r\n      parent.removeChild(currentResult.node)\r\n      currentResult = null\r\n    }\r\n  }\r\n\r\n  // This is ran just once on initialization. If an x-if has just one\r\n  // node and it doesnt pass the initial evaluation, we should stop the\r\n  // walker from walking through the node tree. By returned true from\r\n  // this process, we'll tell the walker to skip this. It's like\r\n  // conditionally adding x-skip to this.\r\n  let shouldGoNextSibling = false\r\n\r\n  ctx.effect(() => {\r\n    // Iterate over each block and evaluate block expressions\r\n    for (let index = 0; index < blocks.length; index++) {\r\n      const block = blocks[index]\r\n\r\n      if (!block.expr || ctx.eval(block.expr, node)) {\r\n        // Passed\r\n        if (currentIndex !== index) {\r\n          if (currentResult)\r\n            clear()\r\n\r\n          parent.insertBefore(block.node, anchor)\r\n\r\n          // Walk and process again\r\n          walk(ctx, block.node)\r\n\r\n          currentResult = block\r\n          currentIndex = index\r\n        }\r\n        else {\r\n          shouldGoNextSibling = true\r\n        }\r\n\r\n        return\r\n      }\r\n      else {\r\n        shouldGoNextSibling = true\r\n      }\r\n    }\r\n\r\n    currentIndex = -1\r\n    clear()\r\n  })\r\n\r\n  // REVIEW Any nodes after a failing x-if, were not being processed Moving this\r\n  // line of code at the end of this file and into requestAnimationFramge fixed\r\n  // it. But I am simply not actually sure how or why.\r\n  // requestAnimationFrame(() => {\r\n  //   parent.removeChild(node)\r\n  // })\r\n\r\n  return shouldGoNextSibling\r\n}\r\n","import { isArr, isNil, parseValue } from '../helpers'\r\nimport type { Directive, Primitive } from './directives'\r\n\r\nexport type ModelModifierFn = (value: string, oldValue: string, param?: any) => unknown\r\n\r\nexport const modelModifiers: Record<string, ModelModifierFn> = {\r\n  trim: (value: string) => value.trim(),\r\n  number: (value: string, prevValue: string) => {\r\n    if (Number.isNaN(Number(value)))\r\n      return Number(prevValue)\r\n\r\n    return Number(value)\r\n  },\r\n} as const\r\n\r\nexport type ModelElement = HTMLInputElement | HTMLSelectElement | HTMLDetailsElement | HTMLTextAreaElement\r\ntype Modifier = keyof typeof modelModifiers\r\n\r\nexport const processModel: Directive = function (ctx, el, { name, value }) {\r\n  let node = el as ModelElement\r\n  const [_, modifier] = name.split('.') as [unknown, Modifier]\r\n  const defaultValue = node.attributes.getNamedItem('value')?.value\r\n\r\n  // Call back to execute model modifiers and return the modified value\r\n  const modify = (newValue: string, oldValue: string) => {\r\n    if (!modifier)\r\n      return newValue\r\n\r\n    // Model param\r\n    const [key, rawParams] = modifier.split('[')\r\n    let param: Primitive\r\n\r\n    if (rawParams) {\r\n      const parsedModifier = rawParams.replace(']', '')\r\n      // The parameter can be a reactive variable.\r\n      // So we should evaluate it against the current context, but only if its available\r\n      param = parseValue(parsedModifier, ctx)\r\n    }\r\n\r\n    return ctx.app.modelModifiers[key](newValue, oldValue, param)\r\n  }\r\n\r\n  const assignSimpleDefaultValue = () => {\r\n    let finalValue\r\n    const modelValue = ctx.eval(value)\r\n\r\n    if (!modelValue) {\r\n      if (defaultValue)\r\n        finalValue = defaultValue\r\n    }\r\n    else {\r\n      finalValue = modelValue\r\n    }\r\n\r\n    Object.assign(ctx.data, { [name]: finalValue })\r\n    node = node as HTMLInputElement\r\n    node.value = finalValue\r\n  }\r\n\r\n  switch (node.tagName) {\r\n    case 'INPUT':\r\n    case 'TEXTAREA': {\r\n      node = node as HTMLInputElement\r\n\r\n      switch (node.type) {\r\n        // Listen for 'change' event\r\n        case 'checkbox': {\r\n          const modelValue = Reflect.get(ctx.data, value) as Array<any> | string | undefined | null\r\n\r\n          /**\r\n           * With checkbox, there are multiple cases\r\n           *  - no value:       we toggle checked state as a boolean\r\n           *  - value:          we toggle checked state as its value\r\n           *  - array no value: nothing, array of random booleans makes no sense\r\n           *  - array values:   push / splice out if checked or not\r\n           */\r\n\r\n          const setCheckboxValue = (value: string, checked: boolean) => {\r\n            // Selected but something else: ARRAY\r\n            if (isArr(modelValue)) {\r\n              if (modelValue.includes(value))\r\n                modelValue.splice(modelValue.indexOf(value), 1)\r\n              else\r\n                modelValue.push(value)\r\n            }\r\n            // Primitive\r\n            else {\r\n              Reflect.set(ctx.data, value, isNil(value) ? !checked : value)\r\n            }\r\n          }\r\n\r\n          // If no model value is provided and element contains checked, assign default value\r\n          if ((!modelValue || modelValue.length === 0) && node.hasAttribute('checked')) {\r\n            setCheckboxValue(node.value, true)\r\n            node.removeAttribute('checked')\r\n          }\r\n\r\n          node.addEventListener('change', (evt) => {\r\n            const { checked, value } = evt?.target as HTMLInputElement\r\n            setCheckboxValue(value, checked)\r\n          })\r\n\r\n          ctx.effect(() => {\r\n            node = node as HTMLInputElement\r\n            // Update in case some properties are removed or set elsewhere\r\n            const results = ctx.eval(value)\r\n\r\n            if (results.includes(node.value) || node.value === results)\r\n              node.checked = true\r\n            else\r\n              node.checked = false\r\n          })\r\n          break\r\n        }\r\n\r\n        // Listen for 'change' event\r\n        case 'radio': {\r\n          // Default value\r\n          if (node.hasAttribute('checked')) {\r\n            node.removeAttribute('checked')\r\n            Object.assign(ctx.data, { [value]: node.value })\r\n          }\r\n\r\n          node.addEventListener('change', (evt) => {\r\n            const { checked, value } = evt.target as HTMLInputElement\r\n            if (checked)\r\n              Object.assign(ctx.data, { [value]: value })\r\n          })\r\n\r\n          // If evaluated value changes, make sure to update the HTML as well\r\n          ctx.effect(() => {\r\n            node = node as HTMLInputElement\r\n            const newValue = ctx.eval(value)\r\n            node.checked = node.value === newValue\r\n          })\r\n          break\r\n        }\r\n\r\n        // All other inputs\r\n        default: {\r\n          assignSimpleDefaultValue()\r\n          node.removeAttribute('x-model')\r\n          node.addEventListener('input', (evt) => {\r\n            const target = evt.target as HTMLInputElement\r\n            const rawValue = target.value\r\n            const modifiedValue = modify(rawValue, Reflect.get(ctx.data, value))\r\n\r\n            // If modified value is different than raw value, we need to\r\n            // re-assign this modification back to the original target.\r\n            if (rawValue !== modifiedValue)\r\n              target.value = String(modifiedValue)\r\n\r\n            Object.assign(ctx.data, { [value]: modifiedValue })\r\n          })\r\n\r\n          ctx.effect(() => (node as HTMLInputElement).value = ctx.eval(value))\r\n        }\r\n      }\r\n      break\r\n    }\r\n\r\n    case 'SELECT': {\r\n      node = node as HTMLSelectElement\r\n      assignSimpleDefaultValue()\r\n\r\n      node.addEventListener('change', (evt) => {\r\n        const val = parseValue((evt.target as HTMLSelectElement).value, ctx)\r\n        Object.assign(ctx.data, { [value]: val })\r\n      })\r\n\r\n      ctx.effect(() => (node as HTMLSelectElement).value = ctx.eval(value))\r\n      break\r\n    }\r\n\r\n    case 'DETAILS': {\r\n      node = node as HTMLDetailsElement\r\n      const defaultOpen = node.attributes.getNamedItem('open')\r\n      const currentValue = ctx.eval(value)\r\n\r\n      node.open = !isNil(currentValue) ? currentValue : (defaultOpen ?? false)\r\n\r\n      node.addEventListener('toggle', (evt) => {\r\n        const isOpen = (evt.target as HTMLDetailsElement).open\r\n        Object.assign(ctx.data, { [value]: isOpen })\r\n      })\r\n\r\n      ctx.effect(() => (node as HTMLDetailsElement).open = ctx.eval(value))\r\n      break\r\n    }\r\n  }\r\n}\r\n","import { isArr, isObj, removeChildren } from '../helpers'\r\nimport type { ContextAny } from '../context'\r\nimport { Context } from '../context'\r\nimport { walk } from '../walker'\r\nimport type { Directive } from './directives'\r\n\r\nexport const processFor: Directive = function (ctx, node, { value, name }) {\r\n  node.removeAttribute(name)\r\n  // Remove if from the iterated elements.\r\n  // Use condition on the child elements instead.\r\n  node.removeAttribute('x-if')\r\n\r\n  /**\r\n   * Much more limited that vue's synax. No destructuring.\r\n   * Only supports 3 different types. Array, object and range (number)\r\n   *\r\n   * Iteration of objects\r\n   *  - item in object\r\n   *  - (value, key, index) in object\r\n   *\r\n   * Iteration of arrays\r\n   *  - item in array\r\n   *  - (item, index) in array\r\n   */\r\n\r\n  // First, we split strings\r\n  const [params, _, rawValue] = value.split(/(?!\\(.*)\\s(?![^(]*?\\))/g)\r\n  const parent = node.parentElement\r\n\r\n  /**\r\n   * REVIEW: maybe in the future\r\n   *\r\n   * Evaluation process\r\n   *\r\n   * 1. Generate nodes once and save them to an array\r\n   * 2. On subsequent evaluations, we cache the expression. And iterate on the cached nodes only.\r\n   *  - If expression changes, we remoe all nodes and go back to step #1\r\n   *\r\n   */\r\n  const originalNode = node.cloneNode(true)\r\n  node.remove()\r\n\r\n  // Methods using this scope's variables\r\n  // Create new node and context by cloning the original node.\r\n  const createForItemCtx = () => {\r\n    const newEl = <HTMLElement>originalNode.cloneNode(true)\r\n    const newCtx = new Context(newEl, ctx.app)\r\n    newCtx.extend(ctx)\r\n    return { newEl, newCtx }\r\n  }\r\n\r\n  // Appends the new element to the parent and walks through attribute setup\r\n  // itself and its children.\r\n  const appendAndWalkItem = (newEl: HTMLElement, newCtx: ContextAny) => {\r\n    parent?.appendChild(newEl)\r\n    walk(newCtx)\r\n  }\r\n\r\n  ctx.effect(() => {\r\n    const evalExpr = ctx.eval(rawValue)\r\n\r\n    // Before clearing, should remoev ALL children if they exist\r\n    removeChildren(parent!)\r\n\r\n    // Range\r\n    if (typeof evalExpr === 'number') {\r\n      for (const i in Array.from({ length: evalExpr })) {\r\n        const { newEl, newCtx } = createForItemCtx()\r\n        Object.assign(newCtx.data, { [params]: Number(i) })\r\n        appendAndWalkItem(newEl, newCtx)\r\n      }\r\n    }\r\n    // Item in array\r\n    else if (isArr(evalExpr)) {\r\n      // Extract values from '(value, index?)' string\r\n      const [valueName, indexName] = params.replace('(', '').replace(')', '').split(',')\r\n      const trimmedValueName = valueName.trim()\r\n      const trimmedIndexName = indexName?.trim()\r\n\r\n      evalExpr.forEach((item, index) => {\r\n        const { newEl, newCtx } = createForItemCtx()\r\n\r\n        Object.assign(newCtx.data, { [trimmedValueName]: item })\r\n\r\n        if (trimmedIndexName)\r\n          Object.assign(newCtx.data, { [trimmedIndexName]: Number(index) })\r\n\r\n        appendAndWalkItem(newEl, newCtx)\r\n      })\r\n    }\r\n    // Iterating in object\r\n    else if (isObj(evalExpr)) {\r\n      // Extract values from '(value, key?, index?)' string\r\n      const [valueName, keyName, indexName] = params.replace('(', '').replace(')', '').split(',')\r\n      const trimmedValueName = valueName.trim()\r\n      const trimmedKeyName = keyName?.trim()\r\n      const trimmedIndexName = indexName?.trim()\r\n\r\n      Object.entries(evalExpr).forEach(([key, value], index) => {\r\n        const { newEl, newCtx } = createForItemCtx()\r\n\r\n        Object.assign(newCtx.data, { [trimmedValueName]: value })\r\n\r\n        if (trimmedKeyName)\r\n          Object.assign(newCtx.data, { [trimmedKeyName]: key })\r\n\r\n        if (trimmedIndexName)\r\n          Object.assign(newCtx.data, { [trimmedIndexName]: Number(index) })\r\n\r\n        appendAndWalkItem(newEl, newCtx)\r\n      })\r\n    }\r\n\r\n    else if (import.meta.env.DEV) {\r\n      throw new TypeError('Unsupported value was used in \\'x-for\\'. Please only use a number, array or an object')\r\n    }\r\n  })\r\n}\r\n","import type { ContextAny } from './context'\r\nimport { parseDelimiter } from './helpers'\r\n\r\nexport function processTextNode(ctx: ContextAny, node: Node) {\r\n  // This should never be hit as only text nodes are processed, but\r\n  // typescript is a known crybaby\r\n  if (!node.textContent || node.textContent.trim().length === 0 || !node.textContent.includes(ctx.app.delimiters.start))\r\n    return\r\n\r\n  const delimiters = ctx.app.delimiters\r\n\r\n  // Save the original expression\r\n  const originalTextContent = node.textContent\r\n  // Extract expressions from text node wrapped within the delimiters\r\n  // For instance { expression }\r\n  const delimitersInclusive = new RegExp(`(?=${parseDelimiter(delimiters.start)})(.*?)(?<=${parseDelimiter(delimiters.end)})`, 'g')\r\n\r\n  // FIXME:\r\n  // using `${}` can match against delimiters containing {}\r\n  // Should use some kind of regex which will ignore \"${\" and the very next \"}\"\r\n\r\n  // Match all occurences of { } within a text node\r\n  const exprGroup = originalTextContent.match(delimitersInclusive)\r\n\r\n  if (!exprGroup || exprGroup.length === 0)\r\n    return\r\n\r\n  ctx.effect(() => {\r\n    let finalTextContent = originalTextContent\r\n\r\n    for (const expr of exprGroup) {\r\n      // Get the expression without the delimiters\r\n      const extractedExpr = expr.replace(delimiters.start, '').replace(delimiters.end, '')\r\n      if (!extractedExpr)\r\n        continue\r\n\r\n      // Evaluate and replace part of the original text content\r\n      const result = ctx.eval(extractedExpr, node)\r\n\r\n      finalTextContent = finalTextContent.replace(expr, result)\r\n    }\r\n\r\n    node.textContent = finalTextContent\r\n  })\r\n}\r\n","import { getAttr } from '../helpers'\r\nimport { applyDirectives } from '../walker'\r\nimport { processTextNode } from '../text-node'\r\nimport type { Directive } from './directives'\r\n\r\n// REVIEW\r\n// Should the target have mutation attached observer attached?\r\n\r\nexport const processPortal: Directive = function (ctx, original, { name, value }) {\r\n  // Clone node, teleport clone to the new place, replace current node\r\n  const clone = original.cloneNode(true) as HTMLElement\r\n  const target = document.querySelector(value)\r\n  const [, elPlacement] = name.split(':')\r\n\r\n  if (!target) {\r\n    // Shouldn't throw, as targets can be removed at runtime\r\n    console.error('No valid target provided for `x-portal`')\r\n    return\r\n  }\r\n\r\n  // Remove original node and append clone to the target\r\n  original.remove()\r\n\r\n  if (elPlacement === 'prepend')\r\n    target.prepend(clone)\r\n  else if (elPlacement === 'replace')\r\n    target.replaceChildren(clone)\r\n  else\r\n    target.append(clone)\r\n\r\n  // Walk the new branch. This code is a compressed clone of the\r\n  // `walk()` function with some differences which aren't necessarily\r\n  // worth an abstraction\r\n  const walker = document.createTreeWalker(clone)\r\n  let node: Node | null = walker.root\r\n\r\n  while (node) {\r\n    if (node.nodeType === Node.ELEMENT_NODE) {\r\n      const _node = node as HTMLElement\r\n\r\n      if (getAttr(_node, 'x-skip') !== null) {\r\n        node = walker.nextSibling()\r\n        continue\r\n      }\r\n\r\n      if (applyDirectives(ctx, _node)) {\r\n        node = walker.nextSibling()\r\n        continue\r\n      }\r\n    }\r\n    else if (node.nodeType === Node.TEXT_NODE) {\r\n      processTextNode(ctx, node)\r\n    }\r\n\r\n    node = walker.nextNode()\r\n  }\r\n}\r\n","import { evaluate } from '../evaluate'\r\nimport { isObj } from '../helpers'\r\nimport type { Directive } from './directives'\r\n\r\nfunction throwDataErr() {\r\n  throw new Error('[x-scope/x-data] Error when processing attribute. \\n Most likely an issue with the the data object.')\r\n}\r\n\r\nexport const processData: Directive<boolean> = function (ctx, node, { name, value }) {\r\n  node.removeAttribute(name)\r\n\r\n  if (name === 'x-scope' && ctx.root !== node)\r\n    throw new Error('Can not initialize a new scope within an existing scope')\r\n\r\n  try {\r\n    if (!value)\r\n      value = '{ }'\r\n\r\n    // throwDataErr()\r\n\r\n    const data = evaluate({}, value)\r\n\r\n    if (!isObj(data))\r\n      throwDataErr()\r\n\r\n    for (const key of Object.keys(data)) {\r\n      Object.defineProperty(ctx.data, key, {\r\n        value: data[key],\r\n        writable: true,\r\n        enumerable: true,\r\n        configurable: true,\r\n      })\r\n    }\r\n  }\r\n  catch (e) {\r\n    console.warn('[x-scope/x-data] Error when processing attribute')\r\n    // console.log(e)\r\n    throwDataErr()\r\n  }\r\n\r\n  return false\r\n}\r\n","import { parseValue } from '../helpers'\r\nimport { walk } from '../walker'\r\nimport type { Directive } from './directives'\r\n\r\ninterface Block {\r\n  isDefault: boolean\r\n  isCase: boolean\r\n  expr: string | null\r\n  node: Element\r\n}\r\n\r\nexport const processSwitch: Directive = function (ctx, node, { value }) {\r\n  node.removeAttribute('x-switch')\r\n\r\n  // Since each case/default can be separated by normal non-switch\r\n  // nodes, we need to replace each with a commenet anchor so we can\r\n  // re-add it to the DOM in the right place\r\n  const anchors: Comment[] = []\r\n\r\n  // Get all child elements which are part of the switch statement\r\n  const blocks = Array\r\n    .from(node.children)\r\n    // Discard nodes which aren't part of the switch\r\n    .filter(c => c.hasAttribute('x-case') || c.hasAttribute('x-default'))\r\n    // Format into a block holding an expression and dom reference\r\n    .map((el): Block => {\r\n      return {\r\n        isDefault: el.hasAttribute('x-default'),\r\n        isCase: el.hasAttribute('x-case'),\r\n        expr: el.attributes.getNamedItem('x-case')?.value ?? null,\r\n        node: el,\r\n      }\r\n    })\r\n    // Remove all nodes from the DOM, they will be reattached based on\r\n    // the expression\r\n    .map((block) => {\r\n      // Insert comment before each node (there can be gaps between cases)\r\n      const anchor = new Comment('x-switch')\r\n      node.insertBefore(anchor, block.node)\r\n      // e.node.insertAdjacentElement('afterend', anchor)\r\n      anchors.push(anchor)\r\n      // Remove beskydy attributes and self\r\n      block.node.removeAttribute('x-case')\r\n      block.node.removeAttribute('x-default')\r\n      block.node.remove()\r\n      return block\r\n    })\r\n\r\n  let currentResult: Block | null\r\n\r\n  function clear() {\r\n    if (currentResult) {\r\n      currentResult.node.remove()\r\n      currentResult = null\r\n    }\r\n  }\r\n\r\n  ctx.effect(() => {\r\n    const result = ctx.eval(value)\r\n    let res: [Block, number] | undefined\r\n\r\n    for (let i = 0; i < blocks.length; i++) {\r\n      const block = blocks[i]\r\n\r\n      // If default is NOT last, we save it in case the following expression are not the result\r\n      if (i < blocks.length - 1 && block.isDefault)\r\n        res = [block, i]\r\n\r\n      if (block.expr) {\r\n        const blockResult = parseValue(block.expr, ctx)\r\n\r\n        if (blockResult === result) {\r\n          res = [block, i]\r\n          break\r\n        }\r\n      }\r\n      else if (i === blocks.length - 1) {\r\n        // We can expect we hit a `x-case` if we are on the last index and\r\n        // block is missing expression\r\n        res = [block, i]\r\n      }\r\n    }\r\n\r\n    if (res) {\r\n      clear()\r\n      const [block, index] = res\r\n      const anchor = anchors[index]\r\n      node.insertBefore(block.node, anchor)\r\n      walk(ctx, block.node)\r\n      currentResult = block\r\n      return\r\n    }\r\n\r\n    clear()\r\n  })\r\n}\r\n","import type { ContextAny } from '../context'\r\nimport type { Directive } from './directives'\r\n\r\n/**\r\n * Runs provided callback each time the context dataset is updated\r\n */\r\nexport const processSpy: Directive = function (ctx, node, { name, value }) {\r\n  // Check wether we are spyng on specific keys in the context dataset\r\n  const [_, ...spyOnParams] = name.split(':')\r\n\r\n  // let firstFired = false\r\n\r\n  // Store previously saved dataset to compare values when we're spying on specific properties\r\n  let previousData: ContextAny['data'] = Object.create(null)\r\n\r\n  ctx.effect(() => {\r\n    // Ignore first fire as that's when the scope is registered\r\n    // if (!firstFired) {\r\n    //   firstFired = true\r\n    //   return\r\n    // }\r\n\r\n    if (spyOnParams.length > 0) {\r\n      for (const key of spyOnParams) {\r\n        if (Reflect.get(previousData, key) !== Reflect.get(ctx.data, key)) {\r\n          ctx.eval(value, node)\r\n          break\r\n        }\r\n      }\r\n\r\n      previousData = { ...ctx.data }\r\n    }\r\n    else {\r\n      ctx.eval(value, node)\r\n    }\r\n  })\r\n}\r\n","import type { Directive } from '..'\r\n\r\n// Simply runs the provided expression\r\n// This is used for lifecycle methods\r\n// `x-init` = runs when all data is registered\r\n// `x-mount` = runs when all other directives have been processed\r\nexport const processLifecycle: Directive = (ctx, node, attr) => {\r\n  node.removeAttribute(attr.name)\r\n  ctx.eval(attr.value, node)\r\n}\n","import { getAttr } from './helpers'\r\nimport type { ContextAny } from './context'\r\nimport { processRef } from './directives/x-ref'\r\nimport { processText } from './directives/x-text'\r\nimport { processStyle } from './directives/x-style'\r\nimport { processShow } from './directives/x-show'\r\nimport { processHTML } from './directives/x-html'\r\nimport { processBind } from './directives/x-bind'\r\nimport { processClass } from './directives/x-class'\r\nimport { processOn } from './directives/x-on'\r\nimport { processIf } from './directives/x-if'\r\nimport { processModel } from './directives/x-model'\r\nimport { processFor } from './directives/x-for'\r\nimport { processPortal } from './directives/x-portal'\r\nimport { processTextNode } from './text-node'\r\nimport { processData } from './directives/x-data'\r\nimport { processSwitch } from './directives/x-switch'\r\nimport { processSpy } from './directives/x-spy'\r\nimport { processLifecycle } from './directives/x-lifecycle'\r\n\r\nexport function walk(ctx: ContextAny, forcedRoot?: Element) {\r\n  const rootEl = forcedRoot ?? ctx.root\r\n  const walker = document.createTreeWalker(rootEl)\r\n  let node: Node | null = walker.root\r\n\r\n  // Before we process directives, we first iterate over any data\r\n  // defining elements This will make sure that all the data objects are\r\n  // available to all elements within a scope/ That means we can\r\n  // reference a variable before it is defined.\r\n\r\n  // This approach might be against javascript conventions, but it is\r\n  // important to remember that the nesting of elements should not\r\n  // matter when usiny Beskydy. Each x-scope and all its descendants\r\n  // should be treated as a single, flat \"scope\".\r\n\r\n  const rootDatasets = (rootEl).querySelectorAll('[x-data]')\r\n  const rootScopeAttr = (rootEl).getAttributeNode('x-scope')\r\n\r\n  if (rootScopeAttr)\r\n    processData(ctx, rootEl, rootScopeAttr)\r\n\r\n  for (const rootDataset of rootDatasets) {\r\n    // We can ignore the fact that getAttributeNode can return null, as\r\n    // all the iterated elements have explicitly been queried by the\r\n    // `x-data` attribute\r\n    processData(ctx, rootDataset, rootDataset.getAttributeNode('x-data')!)\r\n  }\r\n\r\n  ////////////////////////\r\n\r\n  while (node) {\r\n    switch (node.nodeType) {\r\n      case Node.ELEMENT_NODE: {\r\n        // Element\r\n        const _node = node as HTMLElement\r\n\r\n        // SECTION x-skip\r\n        // Elements with x-skip will be skipped during evaluation. The\r\n        // skip includes all elements children. Selects the next sibling.\r\n        if (getAttr(_node, 'x-skip') !== null) {\r\n          node = walker.nextSibling()\r\n          continue\r\n        }\r\n\r\n        // SECTION x-portal\r\n        // A section of DOM disconnected from the context\r\n        // tree but still within the reactive scope. We essentially need\r\n        // to create another walker within this walker to temporarily\r\n        // traverse the detached dom tree\r\n        let portalAttr\r\n        if (portalAttr = Array.from(_node.attributes).find(a => a.name.startsWith('x-portal')))\r\n          processPortal(ctx, _node, portalAttr)\r\n\r\n        // If appliy directives returns true, we want to skip to the next\r\n        // sibling instead of going deeper.\r\n        if (applyDirectives(ctx, _node)) {\r\n          node = walker.nextSibling()\r\n          continue\r\n        }\r\n        break\r\n      }\r\n\r\n      case Node.TEXT_NODE: {\r\n        // SECTION Text Node\r\n        // 1. Save string\r\n        // 2. Extract expression\r\n        // 3. Replace entire content between delimiters with the result of the expression\r\n        processTextNode(ctx, node)\r\n        break\r\n      }\r\n    }\r\n\r\n    node = walker.nextNode()\r\n  }\r\n}\r\n\r\n// Can be re-run on sub-sequent dom changes\r\nexport function applyDirectives(ctx: ContextAny, node: HTMLElement): boolean | void {\r\n  for (const attr of Array.from(node.attributes)) {\r\n    // REVIEW\r\n    // Unsure if the order of attribute processing is correct,\r\n    // but so far it hasn't posed any issues. Just adding this here so\r\n    // later we do a real review\r\n\r\n    // When scope has had its data registered, we can execute the init hook\r\n    if (attr.name === 'x-init') {\r\n      processLifecycle(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    // In case if and for are on the same element, the if is removed.\r\n    if (attr.name === 'x-for') {\r\n      processFor(ctx, node, attr)\r\n\r\n      return true\r\n    }\r\n    else if (attr.name === 'x-if') {\r\n      const shouldSkipNode = processIf(ctx, node, attr)\r\n\r\n      // This looks wonky, but we only want to return a value if the\r\n      // sibling should be skipped. If not, we want this function to\r\n      // continue further.\r\n      if (shouldSkipNode) {\r\n        // REVIEW: ive no fucking clue man\r\n        // return true\r\n      }\r\n\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-switch') {\r\n      processSwitch(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-ref') {\r\n      processRef(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name.startsWith('x-model')) {\r\n      processModel(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name.startsWith('x-bind') || attr.name.startsWith(':')) {\r\n      processBind(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name.startsWith('@') || attr.name.startsWith('x-on')) {\r\n      processOn(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name.startsWith('x-spy')) {\r\n      processSpy(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-text') {\r\n      processText(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-class') {\r\n      processClass(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-html') {\r\n      processHTML(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-style') {\r\n      processStyle(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    if (attr.name === 'x-show') {\r\n      processShow(ctx, node, attr)\r\n      continue\r\n    }\r\n\r\n    // Custom directive implementation\r\n    const keys = Object.keys(ctx.app.customDirectives)\r\n\r\n    if (keys.length > 0) {\r\n      for (const key of keys) {\r\n        const directive = ctx.app.customDirectives[key]\r\n        if (attr.name.startsWith(key))\r\n          directive(ctx, node, attr)\r\n      }\r\n    }\r\n\r\n    // When scope has had its data registered, we can execute the init hook\r\n    if (attr.name === 'x-processed') {\r\n      processLifecycle(ctx, node, attr)\r\n      continue\r\n    }\r\n  }\r\n}\r\n","import type { UnwrapNestedRefs } from '@vue/reactivity'\r\nimport { reactive } from '@vue/reactivity'\r\nimport type { ContextAny } from './context'\r\nimport { Context } from './context'\r\nimport type { Directive, EventModifierFn } from './directives/directives'\r\nimport { walk } from './walker'\r\nimport { eventModifiers } from './directives/x-on'\r\nimport type { ModelModifierFn } from './directives/x-model'\r\nimport { modelModifiers } from './directives/x-model'\r\n\r\n// Custom modifiers warning message, which is shared across all three of them\r\nconst warnEnd = 'is a reserved name or its already been defined. Please use a different name.'\r\ntype Cb = () => void\r\n\r\nexport class Beskydy<T extends object> {\r\n  modelModifiers: Record<string, ModelModifierFn>\r\n  eventModifiers: Record<string, EventModifierFn>\r\n  customDirectives: Record<string, Directive>\r\n  delimiters: {\r\n    start: string\r\n    end: string\r\n  }\r\n\r\n  private scopes: ContextAny[]\r\n  rootState: UnwrapNestedRefs<T>\r\n  private onInitCbs: Cb[]\r\n  private onTeardownCbs: Cb[]\r\n\r\n  constructor(initialDataset?: T) {\r\n    this.modelModifiers = Object.assign({}, modelModifiers)\r\n    this.eventModifiers = Object.assign({}, eventModifiers)\r\n    this.customDirectives = {}\r\n    this.delimiters = {\r\n      start: '{{',\r\n      end: '}}',\r\n    }\r\n    this.scopes = []\r\n    this.rootState = reactive(Object.assign({}, initialDataset))\r\n    this.onInitCbs = []\r\n    this.onTeardownCbs = []\r\n  }\r\n\r\n  /**\r\n   * Define the way Beskydy will compile the delimiters {{ }} into a reactive part of a string.\r\n   * Delimiters contain text, which usually contains an expression. Think of it was as javascript being executed within a string when it is wrapped in the delimiters {{ }}\r\n   *\r\n   *\r\n   * @param start Starting delimiter\r\n   * @param end Ending delimiter\r\n   */\r\n  setDelimiters(start: string, end: string) {\r\n    this.delimiters.start = start\r\n    this.delimiters.end = end\r\n  }\r\n\r\n  /**\r\n   * Add a custom directive (element attribute)\r\n   *\r\n   * @param name Directive name, preferably should start with `x-`\r\n   * @param fn Directive implementation\r\n   */\r\n  defineDirective(name: string, fn: Directive) {\r\n    if (name in this.customDirectives)\r\n      throw new Error(`The directive \"${name}\" ${warnEnd}`)\r\n    this.customDirectives[name] = fn\r\n  }\r\n\r\n  /**\r\n   * Add a custom `x-on` event modifier\r\n   *\r\n   * @param name Modifier name\r\n   * @param fn Modifier implementation\r\n   */\r\n  defineEventModifier(name: string, fn: EventModifierFn) {\r\n    if (name in this.eventModifiers)\r\n      throw new Error(`The event modifier \"${name}\" ${warnEnd}`)\r\n    this.eventModifiers[name] = fn\r\n  }\r\n\r\n  /**\r\n   * Add a custom `x-model` modifier\r\n   *\r\n   * @param name Modifier name\r\n   * @param fn Modifier implementation\r\n   */\r\n  defineModelModifier(name: string, fn: ModelModifierFn) {\r\n    if (name in this.modelModifiers)\r\n      throw new Error(`The model modifier \"${name}\" ${warnEnd}`)\r\n    this.modelModifiers[name] = fn\r\n  }\r\n\r\n  /**\r\n   *  Initialize Beskydy. It starts by collecting all the scope elements\r\n   *  and creating a context for each.\r\n   *\r\n   * @param selector Custom attribute selector. Defaults to 'x-scope'\r\n   */\r\n  collect(selector: string = '[x-scope]') {\r\n    const scopeRoots = Array.from(document.querySelectorAll(selector))\r\n    if (scopeRoots.length === 0)\r\n      console.warn(`No scopes were found for the selector \"${selector}\". Make sure to define at least one.`)\r\n\r\n    for (const scopeRoot of scopeRoots) {\r\n      const ctx = new Context(scopeRoot, this, {})\r\n      // Hide scope until it's initialized\r\n      scopeRoot.setAttribute('style', 'display:none;')\r\n      walk(ctx)\r\n      ctx.init = true\r\n      scopeRoot.removeAttribute('style')\r\n      this.scopes.push(ctx)\r\n    }\r\n\r\n    for (const cb of this.onInitCbs)\r\n      cb()\r\n  }\r\n\r\n  /**\r\n   * Registers a function which runs when app is fully initialized\r\n   */\r\n  onInit(fn: Cb) {\r\n    this.onInitCbs.push(fn)\r\n  }\r\n\r\n  /**\r\n   * Registers a callback which runs after application has been shut down\r\n   */\r\n  onTeardown(fn: Cb) {\r\n    this.onTeardownCbs.push(fn)\r\n  }\r\n\r\n  /**\r\n   *   Stops Beskydy instance, removes reactivity and event listeners\r\n   *   and leaves the DOM in the state it was when the app was torn down.\r\n   */\r\n  teardown() {\r\n    for (const ctx of this.scopes)\r\n      ctx.teardown()\r\n\r\n    this.scopes.length = 0\r\n\r\n    // REVIEW\r\n    // Should the onTeardown callbacks run before teardown or right after?\r\n    for (const cb of this.onTeardownCbs)\r\n      cb()\r\n  }\r\n}\r\n","import { Beskydy } from './beskydy'\r\nimport type { Directive, EventModifierFn, Primitive } from './directives/directives'\r\nimport type { ModelModifierFn } from './directives/x-model'\r\n\r\nexport {\r\n  Beskydy,\r\n  Directive,\r\n  Primitive,\r\n  EventModifierFn,\r\n  ModelModifierFn,\r\n}\r\n\r\n//////////////////////////////////////////////\r\n\r\nconst app = new Beskydy({\r\n  selected: 'people',\r\n  loading: true,\r\n  data: [],\r\n  fetchData() {\r\n    this.loading = true\r\n    fetch(`https://swapi.dev/api/${this.selected}`)\r\n      .then(r => r.json())\r\n      .then((r) => {\r\n        this.loading = false\r\n        this.data = r.results\r\n      })\r\n  },\r\n  // makeElement() {\r\n  //   return document.createElement(\"table\")\r\n  // }\r\n})\r\n\r\n// app.setDelimiters(\"[\", \"]\")\r\n\r\n// app.defineDirective('x-three', (ctx, el, attr) => {\r\n//   ctx.effect(() => {\r\n//     const value: number = ctx.eval(attr.value)\r\n\r\n//     if (value % 3 === 0) {\r\n//       el.textContent = \"DIVISIBLE BY THREE!!!\"\r\n//     } else {\r\n//       el.textContent = String(value)\r\n//     }\r\n//   })\r\n// })\r\n\r\n// Modify the model value\r\n// app.defineModelModifier('maxlength', (value, prevValue, length: number) => {\r\n//   if (value.length > length)\r\n//     return prevValue\r\n//   return value\r\n// })\r\n\r\n// // Modify if event is registered\r\n// app.defineEventModifier('every', (_, state, param) => {\r\n//   return state.calledTimes % Number(param) === 0\r\n// })\r\n\r\napp.collect()\r\n"],"names":["evalCache","evaluate","scope","exp","el","execute","event","fn","toFunction","e","Context","root","app","initialDataset","__publicField","reactive","handler","rawEffect","key","ref","ctx","expr","clone","_a","getAttr","attr","isNil","value","isObj","isArr","removeChildren","node","parseValue","parseDelimiter","delimiter","group","item","processRef","name","processText","processStyle","result","processShow","processHTML","processBind","_","propertyName","setOrDelAttr","results","processClass","assignObjectClasses","parsed","prevInlineResults","i","prevResult","previous","eventModifiers","lastCall","amount","__","rawEval","calledTimes","callLimit","processOn","eventKeyRaw","eventKey","modifiers","modifier","rawParams","param","parsedModifier","state","processIf","parent","anchor","blocks","elseEl","elseExpr","currentIndex","currentResult","clear","shouldGoNextSibling","index","block","walk","modelModifiers","prevValue","processModel","defaultValue","modify","newValue","oldValue","assignSimpleDefaultValue","finalValue","modelValue","setCheckboxValue","checked","evt","target","rawValue","modifiedValue","val","defaultOpen","currentValue","isOpen","processFor","params","originalNode","createForItemCtx","newEl","newCtx","appendAndWalkItem","evalExpr","valueName","indexName","trimmedValueName","trimmedIndexName","keyName","trimmedKeyName","processTextNode","delimiters","originalTextContent","delimitersInclusive","exprGroup","finalTextContent","extractedExpr","processPortal","original","elPlacement","walker","_node","applyDirectives","throwDataErr","processData","data","processSwitch","anchors","c","res","processSpy","spyOnParams","previousData","processLifecycle","forcedRoot","rootEl","rootDatasets","rootScopeAttr","rootDataset","portalAttr","a","keys","directive","warnEnd","Beskydy","start","end","selector","scopeRoots","scopeRoot","cb","r"],"mappings":"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"}